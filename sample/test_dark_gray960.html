<!DOCTYPE HTML><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><title>Document</title> <link href="https://tadavomnist.github.io/assets/css/highlightjs.default.min.css" rel="stylesheet"/><style type="text/css">*,pre code,table,table tr{padding:0}hr,html{overflow:hidden}*{box-sizing:border-box;outline:0;margin:0}body,html{position:relative;width:100vw;height:100vh}html{color-scheme:light}body{padding:10px 15px;overflow:hidden auto;overflow-wrap:break-word;word-wrap:break-word;font:16px/1.4 Helvetica,Arial,sans-serif;color:#333}body,html,table tr{background-color:#fff}.highlight pre,code,pre,tt{background-color:#f8f8f8;direction:ltr!important}table tr :is(th,td){border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}strong,table tr th{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{position:relative;box-sizing:content-box;font-weight:700;padding:15px 0;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;border:0;border-bottom:1px solid #ddd}a{color:#4183c4}a.absent{color:#c00}ol,ul{padding-left:15px;margin:0 7px}ol{list-style-type:lower-roman}table tr{border-top:1px solid #ccc;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr :is(th,td) :first-child{margin-top:0}table tr :is(th,td) :last-child{margin-bottom:0}img{max-width:100%;pointer-events:none}blockquote{padding:0 15px;border-left:4px solid #ccc}code,tt{margin:0 2px;padding:0 5px;overflow-wrap:break-word;border:1px solid #eaeaea;border-radius:3px}tt{white-space:nowrap}pre code{white-space:pre;border:none}.highlight pre,pre{border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;margin:.8em 0 1em;border-radius:3px;max-width:calc(100% - 2px)}#container{width:960px;margin: 0 auto;}*,html,body{background-color:#333;color:#fff;}code{background-color:#212121 !important;color:rgb(0,183,255) !important;}pre{background-color:#433f3f !important;}</style></head><body><div id="container"><h1>Comparison of RAM and HDD Read/Write Speeds</h1><br />
<h2>Abstract</h2><br />
<p>This article provides a detailed comparison of the speed at which data is read and written on RAM and a hard disk drive (HDD). The underlying technology of both RAM and HDD is explained, followed by a comparison of their average read/write speeds considering technological complexities.</p><br />
<h2>Purpose of Comparing RAM and HDD Speed</h2><br />
<p>RAM vs HDD</p><br />
<p>A few years ago, during a discussion on a programming forum, I mentioned that the average read/write speed of a hard disk drive is approximately 100,000 times slower than RAM. This statement seemed strange to many programmers, and not everyone accepted it. To justify my claim, I had to explain the technical aspects of RAM and HDD. </p><br />
<p>In this article, I will discuss why the average speed of a HDD is, on average, a hundred thousand times slower than RAM.</p><br />
<p>First of all, it is important to note that an accurate statement cannot be made regarding the speed comparison between HDD and RAM. Claiming that HDD is exactly that much slower than RAM shows a lack of understanding of the subject in a person.</p><br />
<p>Secondly, Comparing hard disk drives and RAM cannot be accomplished in a single article :) One can write a multi-volume book about RAM and another multi-volume book about HDD, and then compare them in a multi-volume book together! The depth of the subject is vast, and it extends beyond a simple comparison based on internet speed mentions.</p><br />
<p>It's not as simple as saying, "Hey, the internet states that HDD speed is X, and RAM speed is Y, so let's just do the math and divide." Nope, this topic is way more complex! It's the kind of thing that could be explored in a doctoral thesis, with someone dedicating their entire PhD research to it and writing a lengthy paper. Yet, even then, the subject would still not be fully covered.</p><br />
<p>I said these stuff to highlight the complexity of the topic... üò¨‚ù§Ô∏è</p><br />
<p>Most of the information presented here regarding hard disk drives is sourced from Professor Abraham Silberschatz's book, "Database System Concepts, 6th Edition."</p><br />
<p>Now let's move on to the main story.</p><br />
<h2>What is a RAM?</h2><br />
<p>RAM stands for Random Access Memory, which is a type of memory with random access. The name itself explains all the necessary information about RAM that we need to know. Imagine you have a large piece of memory that has relatively high speed (compared to technologies like disks and even things like EEPROMs) and its abstract representation is something like this: </p><br />
<p><img src="Files/Abstract_RAM_schema.png" alt="Abstract RAM schema" /></p><br />
<p><em>An Abstract RAM Model</em></p><br />
<p>Imagine each cell as a byte. You can store information in a continuous sequence of n bytes with a decently fast speed. This level of speed allows the operating system to quickly store its current computation data (Look up for <strong>Memory address register</strong>).</p><br />
<p>But why is it so fast?</p><br />
<p>From a hardware implementation perspective, this memory is structured like a two-dimensional array, similar to a matrix. The "Random Access" structure allows us to access all different cells of memory simultaneously at the same time, but how?</p><br />
<p>Let's examine the logical block structure of RAM:</p><br />
<p><img src="Files/RAM_Logical_structure.png" alt="RAM Logical structure" /></p><br />
<p><em>An 8bit RAM - image source: <a href="https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm">ETSU</a></em></p><br />
<p>Nowadays, Random Access Memories (RAMs) consist of small cells arranged in a two-dimensional grid. Each RAM contains an <code>Address Decoder</code> unit that takes in a binary encoded address and decodes it to determine which memory cell should be accessed for reading or writing. Additionally, there is a <code>Read/Write</code> unit that determines whether data should be written to or read from the selected cell. When using multiple memory chips (So as real world RAMs), a unit called <code>Cheap-Select</code> is employed to facilitate the selection process. The RAM chip cells also have a data input/output component known as the <code>databus</code>. It uses low voltage to represent 0 and high voltage to represent 1. To understand the schema of RAM, you can assume that each row of the RAM is 8 bits long, which is equivalent to 1 byte.</p><br />
<p>Suppose you want to write in the 1000th (1000) memory cell. To do so, you need a 10-bit address-decoder (By using a 10-bit address-decoder, you can access memory locations up to 1024. This is because 2 raised to the power of 10 equals 1024). So, you convert the decimal number 1000 to binary, which is <code>1111101000</code>. This binary address is sent to the address decoder. The address decoder uses internal logic gates to interpret the binary address and select the corresponding memory row for read/write operations. This is where it differs from technology like a disk. In a disk, you would need to iterate and pass through a sequence of cells to reach the desired location. But here, there's an address-decoder that activates a special circuit for direct access to the desired memory location. In this way we not only avoid physical movement (compared to a disk), but we also eliminate the need for moving from one memory location to another (compared to other technologies), so the speed rises up.</p><br />
<p>The figure below shows a 3-bit address-decoder. With 3 bits, you can have 8 different states or combinations. So, a 3-bit address-decoder can address and select 8 memory locations with the same speed.</p><br />
<p><img src="Files/3bit_Address_Decoder.png" alt="3-bit Address-Decoder" /></p><br />
<p><em>A 3-bit Decoder with 8 Outputs - Image Source: <a href="https://codestall.wordpress.com/2017/09/02/532-decoder-design-using-4-38-decoders-and-1-24-decoder-in-verilog/">Codestall</a></em></p><br />
<p>A 10-bit address decoder is just like this, and it can select up to 1024 different rows. But hey, you can't fit an image of a 10-bit address decoder in this article! üòÑ</p><br />
<p>So that's the meaning of the "Random Access" structure, which refers to a hardware design where the access time to each memory cell is the same. We can achieve that by implementing a logical gate called an address decoder.</p><br />
<p>If access time is very fast, why don't we replace slow things like HDDs with RAMs and use "Random Access" instead? Well, because of how RAM is designed (logical and electronic structure), it loses all its data, and cells are reset to zeros when the power is turned off. So it can't be used as a stable memory for long-term storage. It's only suitable for storing the information needed for ongoing computations.</p><br />
<p>These days, memory devices like SSDs, which have no physical movement, are being used in some places instead of things like HDDs. They are much faster because they don't have physical activities, but they also have their own issues. Maybe in the future, we'll discuss those technologies in a separate article.</p><br />
<p>Let's get back to RAM, When it comes to designing hardware technologies, RAM can be categorized into two types:  Static RAM (SRAM) and Dynamic RAM (DRAM).</p>
<ul>
<li>Static RAMs (SRAM):</li>
</ul><br />
<p>Static random-access memory (SRAM) stores data in transistor-based circuits similar to D-flip flops. The data remains there as long as the RAM has power and will not be lost. SRAMs are smaller and faster and have simpler decoders compared to dynamic random-access memory (DRAM). They are commonly used in high-speed processes such as caching and very fast applications. In some cases where important data needs to be stored in RAM, SRAM is used, and a backup battery is added to the circuit. This way, even if the circuit loses power for some reason, the system's battery will supply power and prevent data loss.</p>
<ul>
<li>Dynamic RAMs (DRAM):</li>
</ul><br />
<p>Dynamic random access memory (DRAM) stores information on capacitors. These capacitors have a small structure, which increases the overall memory capacity. However, they have a significant problem: Each capacitor naturally loses its internal current and de-charges after a certain period of time due to its natural structure, resulting in the loss of stored information. This process is called "leakage current". To prevent data loss, the contents of all capacitors need to be rapidly read and written back, so that the capacitors remain charged and the information is not lost. This process is referred to as "refreshing circuit". Therefore, in DRAMs, there must be a circuit that continuously reads and writes the information on all capacitors quickly. Furthermore, dynamic RAMs are often cheaper than static RAMs. And of course, the RAMs currently used on your computer are likely to be dynamic.</p><br />
<p>I suggest you read the interview with Steve Wozniak from <a href="http://www.foundersatwork.com/steve-wozniak.html">here</a>. Despite it being a personal and ordinary interview, it contains a lot of professional electronic explanations! In one part of the interview, Wozniak talks about RAM technologies, which is very interesting:</p><br />
<p><em>¬´So I searched around. My thinking was always, in making something possible, you've got to get it down to a reasonable cost, but I needed 4K bytes of RAM minimum. The first dynamic RAMs got introduced that year, 1975, the first 4K dynamic RAMs. That was the first time ever that RAMs were lower in price than magnetic core memories, which every computer up to that day had used. So all of a sudden, the world was going to change to RAMs. Silicon was going to be our memory. Everybody else in the world, the Altair, the Sphere computers, the Polymorphic computers, the Insight computers, every one was designed by basically insufficient engineers, not top quality engineers. They were designed by technicians who knew how to look at the datasheets for some RAM, look at the datasheets for a microprocessor and see if the microprocessor had some lines called "address," and the RAMs had lines called "address" and they would hook a wire from one to the other. It's a very simple job. If your RAMs are static RAMs. The dynamic RAMs were going to be 1/4 the price. The dynamic RAMs meant that instead of 32 chips to have enough memory for a computer to have a language, you only needed 8 chips of RAMs. But dynamic RAM needs all this circuitry to get into every single address in the RAM every 2000th of a second, read what was there and write it back, or it forgets it. Dynamic RAM (this is what we have in our computers today) will forget every single bit in a 2000th of a second unless something reads it and writes it back the way it was to hold its state. It's like little electrons stored on a plate and they'll leak off in a 2000th of a second.¬ª</em></p><br />
<p>The interview link:<br />
<a href="http://www.foundersatwork.com/steve-wozniak.html">http://www.foundersatwork.com/steve-wozniak.html</a></p><br />
<p>And I have almost covered all the technical issues I wanted to discuss regarding RAM. The operating system is responsible for managing RAM. The computer's CPU works with Virtual Addressing, while RAM works with Logical Addressing. In future, I will write a separate article on how the operating system allocates RAM to processes, and another article on how we can access the entire system RAM with it's current cell values.</p><br />
<h2>What is a Hard Disk?</h2><br />
<p>Hard disks are circular plates that store information based on their structure. The first type of disks can be seen in gramophones, where sound vibrations create a spiral groove on a rotating disk. A softer needle moves within the groove to reproduce the sound using vibrations.</p><br />
<p>Later, magnetic hard disks and optical disks like CDs and DVDs were developed. Magnetic hard disks use magnetization to write information in binary form on round disks. Optical disks use lasers to burn information.</p><br />
<p>In general, a disk refers to a rotating, circular plate where information is written in different parts of it.</p><br />
<p>A hard disk consists of magnetic round disks on which information is written by magnetizing each tiny particle in binary form. It typically has multiple layers called platters, with the number of platters usually ranging from 1 to 5.</p><br />
<p>A cross-sectional view of a hard disk would look like this:</p><br />
<p><img src="Files/HDD_Platters.jpg" alt="HDD Platters" /></p><br />
<p><em>Image source: <a href="https://www.compuclever.com/posts/hard-disk-drive-basics/ic306536/">compuclever</a></em></p><br />
<p>An abstract representation of the cross-sectional view:</p><br />
<p><img src="Files/HDD_Abstract_Platters.jpg" alt="HDD Abstract Platters" /></p><br />
<p><em>Image source: The Book: Database System Concepts, 6th Edition</em></p><br />
<p>The platters of a hard-disk are magnetic surfaces that can store 0s and 1s by being magnetized. These platters are logically divided into different sets of concentric circles, which are composed of circular tracks that form the disk. Each of these concentric circles is referred to as a "track".</p><br />
<p>In the image below, you can observe several abstract tracks:</p><br />
<p><img src="Files/HDD_Tracks.jpg" alt="HDD Tracks" /></p><br />
<p><em>Image source: <a href="https://www.schoolcoders.com/memory-storage/secondary-storage/hdd/">schoolcoders</a></em></p><br />
<p>The track itself is divided into smaller parts called "sectors". You can see the sector portion in the image below:</p><br />
<p><img src="Files/HDD_Sectors.jpg" alt="HDD Sectors" /></p><br />
<p><em>Image source: <a href="https://slideplayer.com/slide/1517076/">slideplayer</a></em></p><br />
<p>A sector is also the smallest unit on a disk that is written/read. Usually, a sector has a size of 512 bytes.</p><br />
<p>There is also a component in a hard-disk called the "arm", which has a "head" that moves back and forth. The arm itself rotates and reads/writes these sectors.</p><br />
<p>Naturally, outer tracks (those with larger radius) have more sectors than inner tracks (smaller radii)...</p><br />
<p>Any type of information that needs to be written on a disk must be written in the form of 0s and 1s, (say true or flase, magnetized or not not-magnetized) encoded in binary format, and given to the arm to be written by the head. The same process applies for reading.</p><br />
<p>Depending on the different software formats used to format hard disks, there are various software technologies related to data storage, such as inode and MFT, which we will discuss in other articles later on.</p><br />
<h2>Comparison of Hard Disk and RAM Speed</h2><br />
<p>Let's ignore all the complexities of implementation, operational details, and stuff related to the operating system and RAM, and focus on the hard-disk for now:</p><br />
<p>When considering the speed of a hard-disk, we need to take into account the average speed of I/O operations, which means the input/output activities of the hard disk:</p>
<ul>
<li>I/O = Input/Output</li>
</ul><br />
<p>Calculating this speed is a highly complex task, and there are thousands of factors involved. Each factor requires an extensive explanation, and ultimately, if we manage to accurately model all of these factors (which is very difficult),  the performance of the hard disk drive (HDD) can vary significantly across various scenarios. It can be as much as 10,000 times slower or even up to 500,000 times slower than RAM. To provide a statistical representation, we often present an average, such as 100,000 times slower.</p><br />
<p>Generally, hard disk drives (HDDs) are slower compared to many other technologies because they involve physical and mechanical movements to store data. To give a real-world example, computer experts often observe that using a mouse for interacting with a computer significantly slows down the speed of interaction. If you can accomplish a task using a keyboard, it can be much, much faster than using a mouse. This is a well-known principle. The reason behind this is that the mouse requires a lot of physical movements. For instance, you need to scroll multiple times to perform a task. The keyboard, on the other hand, minimizes physical movements, which makes it faster. The hard disk drive operates in a similar way to a mouse, we will discuss it further.</p><br />
<p>A hard disk drive consists of one or multiple rotating disks (similar to CDs) and a head (like the needle on a gramaphone) that can move up and down on a circuit placed on the disk's radius. This way, it can process the entire disk.</p><br />
<p>Take a look at the animation below, showing the phisical movement of an HDD head:</p><br />
<p><img src="Files/HDD_head_move.gif" alt="HDD head move" /></p><br />
<p><em>I don't remember the source of the GIF - if you know it, let me know!</em></p><br />
<hr /><br />
<p>We measure the speed of a hard disk by <strong>"Transfer time"</strong>, which is a combination of several factors, including:</p><br />
<ol><br />
<li>Read/Write speed of the head: This speed itself depends on various factors, and it's quite complex to explain in detail here.</li><br />
<li>Arm movement speed: Refers to the speed at which the arm moves up and down.</li><br />
<li>Disk rotation speed: Different hard disks have different rotation speeds.</li><br />
<li>Track capacity: Represents the size of each track on the disk.</li><br />
<li>Sector capacity: The capacity of each sector on the disk.</li><br />
<li>Amount of data requested: The size of the data that needs to be accessed.</li><br />
<li>Rotational latency:  Refers to the delay caused by disk rotation speed. A brief explanation will be provided here, but for more details, please refer to the introduced book.</li><br />
<li>Seek time: Represents the delay in positioning the head for accessing specific data.</li><br />
<li>Hard-disk interleaving: I will provide an explanation for this interesting concept and discuss its difference compared to RAM interleaving.</li><br />
<li>Read ahead technique: I will provide an explanation for this as well.</li><br />
<li>Buffer sizes: The capacity of the buffer used in the buffering technique.</li><br />
<li>Disk scheduling algorithms: This topic could fill an entire 12-volume book! It is challenging to explain it briefly. It covers algorithms such as the "Elevator algorithm" or SCAN and more stuff. Without these scheduling algorithms, the hard disk's performance would be significantly slower.</li><br />
<li>Storage of the Files (Data Placement): This requires a very detailed explanation. You might have heard of disk fragmentation, which slows down disk speed. I will explain it further.</li><br />
<li>Storing logs on the hard disk - This aspect will not be discussed in this article.</li><br />
<li>Caching of requests by the operating system, which goes beyond the scope of our discussion.</li><br />
<li>Device management, or as Windows folks call it, drive management, is a highly specialized topic that I won't discuss.</li><br />
<li>... There are so many factors affecting disk speed that if I were to mention all of them, I might never be able to finish this article. To be honest, I'm not familiar with all the details as it is a highly professional field. Experts in file systems can provide better explanations..</li><br />
</ol><br />
<p>Now, transfer time, as mentioned earlier, is the sum of all these delays and timings mentioned above.</p><br />
<hr /><br />
<p>Now let's move on to the explanation of the factors I mentioned. Let's start with the explanation of the first two ones, which are really cool and important:</p><br />
<p>RAM is independent of physical movements, but hard disks consume time/energy in physical movement.</p><br />
<p>Two important physical time consumptions in hard disks:</p><br />
<p>1- <strong>Rotational latency time</strong><br />
Hard disks have a time consumption when they rotate disksüíø.<br />
Suppose a piece of data that you want to read or write is not in that specific position/degree of the disk where the arm is currenty positioned, and the disk needs to rotate like 260 degrees to reach that specific position of the data! The time spent on rotating is called rotational latency time.</p><br />
<p>2- <strong>Seek time</strong><br />
Disks have another time consumption, which is when the arm of HDD needs to move up and down and precisely position on the corresponding radius to find the sector. It's called seek time.</p><br />
<p>Just these two physical movements are enough to make the hard disk very slow and prevent it from being used for storing current computing data like RAM. But the good thing is that the data is not lost when power is gone:3</p><br />
<p>See the image below:</p><br />
<p><img src="Files/seektime_vs_rotationallatencytime.jpg" alt="seek-time vs rotational-latency-time" /></p><br />
<p><em>I don't remember the source of image too - let me know if you do!</em></p><br />
<p>The right one is rotational latency time,<br />
the time when the disk has to wait and do nothing, while the disk rotates and reaches the desired sector.</p><br />
<p>On the left is seek time,<br />
the time when the arm has to move and go to the radius where the desired sector is.</p><br />
<hr /><br />
<p><strong>Block Interleaving in Hard Disk:</strong></p><br />
<p>We have several types of interleaving which are data handling architectures, including:</p>
<ul>
<li>
<p><strong>Bit-interleaved</strong> architecture:
Means that data is read/written bit by bit in some memory/storage.</p>
</li>
<li>
<p><strong>Byte-interleaved</strong> architecture:
Means that data is read/written byte by byte in some memory/storage.</p>
</li>
<li>
<p><strong>Block-interleaved</strong> architecture:
Means that data is read/written in chunks or in other word blocks, in some memory/storage - the block size is determined by the operating systems.</p>
</li>
</ul><br />
<p>So, what's the difference?</p><br />
<p>Back in the early days of computers, data used to be read/written bit by bit, which is quite inefficient since most data we work with requires at least one byte. That's why byte-interleaved architecture was introduced and used...</p><br />
<p>Today, It is safe to say that you can't read/write just a single bit of information from/to a disk or any memory like RAM; you have to read/write at least one byte. For example, a Boolean variable (TRUE/FALSE) only requires one bit to represent TRUE or FALSE, but it is allocated with 8 bits because the memory is byte-interleaved :)</p><br />
<p>Now, in hard disks, block-interleaving has been introduced. When you request a specific byte from the hard disk, it would be inefficient to make the disk rotate and move the arm and head up and down just for one byte! And what if you ask for the next byte afterward? Should the HDD make the disk rotate again to find the next byte?<br />
The HDD is smarter than that! It retrieves a block of data and give it to you and tells you to fetch as much data as you need from that block. If you need more, just ask!<br />
For example, it provides 1024 bytes to the operating system, and if the operating system only needs the first byte, it retrieves first byte and drops the rest...<br />
This concept is not arbitrary; it has been developed for years and tested by thousands of people, who have found out that block-interleaving brings better performance for HDDs compared to byte-interleaving.</p><br />
<p>Now, let's assume that RAM is byte-interleaved, and the hard disk is block-interleaved.</p><br />
<p>This difference significantly slows down the HDD compared to RAM.</p><br />
<hr /><br />
<p><strong>Read Ahead Technique for Hard Disk:</strong></p><br />
<p>This is a concept similar to what I explained earlier but quite different!</p><br />
<p>The read-ahead technique in hard disks is a strategy used to optimize data retrieval and loading times. It involves reading data ahead of time into a buffer or cache before it is actually requested by the system or application.</p><br />
<p>When the system or application requests the next set of data, it is already available in the cache, eliminating the need for the hard disk to seek and retrieve it from the disk platters. This significantly reduces the access time and improves overall performance, especially in cases where consecutive data blocks are accessed sequentially.</p><br />
<p>For instance, a hard disk has understanded through years of system's behavior that consecutive sectors may be needed by the user (operating system or application). So, even though the operating system doesn't explicitly request a specific block count, the hard disk provides it in the cache. This means that if those fetched sectors (cached) are needed and used, the OS or application doesn't have to make another system-call, and wait for the request to be directed to the hardware driver, and then wait for disk's motor to be turned on, the storage table to be read again, the sector number to be determined, the head to be moved up and down, and the data to be read magnetically and returned and... ü•¥</p><br />
<hr /><br />
<p><strong>Buffering Capacity in Computer Science:</strong></p><br />
<p>Buffering, in computer science, refers to a temporary storage area. The buffering capacity represents the amount of temporary storage allocated for buffering data in a computer system.<br />
When it comes to HDD buffering, a portion of the computer's RAM is utilized to store data that is fetched from the hard disk. This data is held in the buffer temporarily, allowing it to be processed or accessed more efficiently before being transferred to other parts of the system.<br />
The buffering capacity differs among different operating systems, and it plays a crucial role in determining the overall speed and efficiency of data processing. Operating system experts should provide better detailed explanation and discussion about buffering and its impact on system performance :3</p><br />
<hr /><br />
<p><strong>Hard-Disk Scheduling Algorithms:</strong></p><br />
<p>There is a common misconception that only one I/O operation can occur on a hard disk at a time. However, in reality, numerous read and write requests are submitted simultaneously when interacting with a hard disk. Thousands of requests are being sent and received. To efficiently handle these requests, sophisticated scheduling algorithms are needed.</p><br />
<p>Let's consider a scenario where hard-disks have a single arm, head, and disk (we won't focus on multiplatters). When there is only one head and one disk, it becomes necessary to implement optimized scheduling algorithms to efficiently satisfy the given requests. These algorithms can be bloody sophisticated!</p><br />
<p>Disk scheduling is a highly complex topic. Apart from discussions about the operating system and its software, powerful hardware algorithms are also needed to optimize disk performance.</p><br />
<p>For example, there is an algorithm called Elevator or SCAN. This algorithm prioritizes certain requests based on the current position of the disk head and the direction of rotation. It aims to minimize head movement and prioritize requests that follow the current path. In the Elevator or SCAN algorithm, when the disk is rotating and the head is on specific sectors, it takes into consideration upcoming requests (let's say three I/O requests after the current one) and performs read/write operations on these sectors. This allows the algorithm to efficiently utilize the current position and avoid ignoring relevant requests. Additionally, while the head is moving in a particular direction, the algorithm does not change the direction of the head and performs read operations on the next request. This may require significant effort and time for HDD. It helps to seamlessly continue processing another request (say the fifth one) on the same track without unnecessary head movements, and then return for another request (say the first one).</p><br />
<p>It's like an elevator that goes up and is on floor 16, but if someone presses the button on the first floor, it won't go down and pick them up and then go to the 20th floor. Instead, it will pick up the person on the 20th floor and then go to the first floor. In between, if someone else presses the button on the second floor, the elevator will pick them up before the person on the first floor. This algorithm itself can be explained in detail, but let's move on... :))</p><br />
<p>There are thousands of other algorithms! This is a very extensive optimization topic. ^_^</p><br />
<p>If these algorithms were not implemented, we would have to wait for 70 years to perform an I/O operation on a disk.</p><br />
<hr /><br />
<p><strong>Storage of the Files (Data Placement):</strong></p><br />
<p>This is perhaps the most important discussion...</p><br />
<p>You can never use a disk as a processing memory (like RAM) because of its sophisticated data placement...</p><br />
<p><em>I'm also writing an article about recovery where I explain disk fragmentation.</em></p><br />
<p>Fragmented Disk:</p><br />
<p><img src="Files/Fragmented_HDD.jpg" alt="Fragmented HDD" /></p><br />
<p>File fragmentation occurs when the available disk space is not large enough to fit the entire file in a contiguous manner. As a result, the file is split into fragments (gets scattered) and stored in non-adjacent sectors on the disk. This can lead to inefficient disk usage and slower file access times.</p><br />
<p>When a fragmented file is accessed, the disk's read/write head needs to move between different locations on the disk to retrieve all the fragments. This physical movement of the read/write head increases the access time, resulting in slower file operations. Fragmentation can significantly impact system performance, especially for larger files or when there are numerous fragmented files on the disk.</p><br />
<p>A fragmented disk, is a disk full of fragmented files. Over the time most of disks get fragmented due to centain amounts of altering/rewriting/deleting files.</p><br />
<p>In truth, the speeds that you refer as transfer-time, must always be based on a fragmented disk, which itself slows down the process thousands of times.<br />
In RAM, we don't have fragmentation, or rather, we do have it, but it doesn't affect speed - A RAM is designed to be fragmented. RAM, as I explained, allows simultaneous access to all its cells ("Random Access").</p><br />
<p>Reading/Writing data and working with tables on a hard disk (things like inode or MFT) are also highly resource-intensive and time-consuming.</p><br />
<p>So, in short, the transfer time of the hard disk, which is affected by everything I mentioned along with thousands of other factors, is very slow.<br />
The physical movement of the disk is so bloody slow that it can be watched by the human eye!</p><br />
<p>In RAM, the architecture is implemented with logical gates, and its speed depends on the flow of electrons (free electrons).</p><br />
<p>I found a video that demonstrates a simple representation of how a "Copy and Paste" process works on a hard disk in slow motion.</p><br />
<p>The physical movements of the hard disk, which can be observed when the HDD box is opened and carefully observed üò¨:</p><br />
<p><a href="https://www.youtube.com/watch?v=3owqvmMf6No">https://www.youtube.com/watch?v=3owqvmMf6No</a></p><br />
<p>The movement that is visible to the naked eye and can be captured by a camera is definitely much slower than the speed of electron movement :)<br />
In general, being 100,000 times slower is completely logical, but let's use our programming knowledge and test for ourselves to see how the theory in practice!</p><br />
<h2>Speed Comparison between RAM and HDD</h2><br />
<p>Our goal is to run some scripts and programs that can test the claim we made about the hard disk being 100,000 times slower than RAM.</p><br />
<p>We will divide our test and experiment into two different phases, and I'll explain why: Before we proceed, let's understand the unique characteristics of RAM and the hard disk. As I mentioned earlier, RAMs are higly fast and are ideal for real-time calculations. They are suitable for computations with a high allocation rate and also for small, frequent datas. Hard-disks on the other hand, are suitable for storing large amounts of data, usually files, and retaining it for a long period. A RAM cannot store very large data because its capacity is limited and usually lower than things like disks and additionally, all its contents are lost when the power supply is cut off. The speed limitations of a hard disk prevent it from efficiently storing small, intricate data at a rapid rate and achieving optimal allocation for such data. So, as they both have different mechanisms they also have different functions, and Therefore we perform our experiment in two phases.</p><br />
<p>In the first phase, we will compare the speed of working with large datas, which are typically handled by the hard disk, in both RAM and the hard disk itself.</p><br />
<p>In the second phase, we perform a comparison experiment with small and computational data that require fast storage, usually RAM, in both RAM and HDD.</p><br />
<p>Regarding the comparison tools, my favorite programming language is <code>PHP</code>. But when it comes to measuring time complexity/resource usage of algorithms and we want to perform experiments comparing the time/resource consumption of different methods, my opinion is that we should always use languages closer to a lower-level machine codes. Compiler-based languages like <code>C</code> and <code>C++</code> always give us much more access, proximity, and efficiency to resources such as RAM and disk. Also, because of their compiler structure, they translate code into machine language, which is solely responsible for executing the algorithm and is less involved in overhead computations like interpreting. By using these languages, the results of our experiments are less affected by the time/resource waste caused by code interpretation or the execution of interpreter, translator, and compiler processes. That's why we use the <code>C++</code> language in this experiment.</p><br />
<hr /><br />
<h3>Phase 1: Comparing the Speed of RAM and Hard Disk in Handling Large Data</h3><br />
<p>Consider the following code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_write_test.cpp">Source code</a></p><br />
<p>This code measures the execution time and the amount of RAM consumed by a specific piece of code. The specific piece of code is the segment below, which allocates exactly 1 gigabyte (1073741824 bytes) of RAM to an array of characters. In simple terms, this code, exactly allocates 1 gigabyte of data in the RAM:</p>
<pre><code class="language-cpp">char* arr = new char[1073741824];
for(int i = 0; i &lt; 1073741824 ; i++)
    arr[i] = 'A';</code></pre><br />
<p>When you run this code, you can get a good estimate of how long it takes to store 1 gigabyte of data in memory in "Random Access" method and how much memory (RAM) is used (which should use exactly 1 gigabyte). This code measures the execution time of that specific segment, once using the clocks in the ctime library and again using the chrono library. This way, we can get a relatively accurate output time. Remember that including iostream (at least in my compiler <code>g++</code>) also links the ctime library to the code. If that didn't happen in your compiler, make sure to manually include the library:</p><br />
<p><code>#include &lt;ctime&gt;</code></p><br />
<p>Let's run the code to see the output. I'm using a Linux machine, so I compile the code with <code>g++ RAM_test.cpp</code> and run it using <code>./a.out</code>.</p><br />
<p>Note: Always remember to repeat the experiment (running the code) at least 3 times in different conditions and consider the overall average as the answer. At any given moment, there are thousands of other processes running on a computer that interact with resources. The behavior of these processes may affect your experiment's results at different times.</p><br />
<p>Note 2: There is a famous Unix command called <code>time</code> that allows you to have some extra information about the command you are running. I'm using this package to monitor the times and CPU consumption during program execution. I will explain the meaning of this information exactly after the execution.</p><br />
<p>Running the code:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ RAM_write_test.cpp 

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out 
Execution Time (Based on ctime): 2501.88 ms
Execution Time (Based on chrono): 2501.97 ms
Memory Usage: 1046800 KB

real    2.51s
user    2.36s
sys     0.14s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2440.13 ms
Execution Time (Based on chrono): 2440.23 ms
Memory Usage: 1046864 KB

real    2.45s
user    2.32s
sys     0.13s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2446.16 ms
Execution Time (Based on chrono): 2446.23 ms
Memory Usage: 1046772 KB

real    2.45s
user    2.32s
sys     0.13s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2444.35 ms
Execution Time (Based on chrono): 2444.5 ms
Memory Usage: 1046848 KB

real    2.45s
user    2.29s
sys     0.16s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2515.03 ms
Execution Time (Based on chrono): 2515.09 ms
Memory Usage: 1046832 KB

real    2.52s
user    2.39s
sys     0.13s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2438.22 ms
Execution Time (Based on chrono): 2438.28 ms
Memory Usage: 1046844 KB

real    2.45s
user    2.32s
sys     0.12s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2493.81 ms
Execution Time (Based on chrono): 2493.94 ms
Memory Usage: 1046784 KB

real    2.50s
user    2.35s
sys     0.15s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2501.99 ms
Execution Time (Based on chrono): 2502.09 ms
Memory Usage: 1046852 KB

real    2.51s
user    2.37s
sys     0.14s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2459.47 ms
Execution Time (Based on chrono): 2460.05 ms
Memory Usage: 1046872 KB

real    2.47s
user    2.32s
sys     0.15s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2429.63 ms
Execution Time (Based on chrono): 2429.75 ms
Memory Usage: 1046772 KB

real    2.43s
user    2.32s
sys     0.12s
cpu     99%
</code></pre><br />
<p>I ran this code on my system in 10 different time intervals when the system was engaged in different computations each time, and the output was as mentioned above. As you can see, the execution time varies within a certain range, but there are slight changes each time. These are the results of the parallel processing capabilities of our operating system. I will write an article later about parallel computations in the operating system. Another interesting matter is that the amount of memory consumed is different in each execution, which seems a bit strange. However, it can be explained in detail, and then we will see that it is completely decent. Explaining the matter in a detailed manner is beyond the scope of this article, but in short, we can say that the performance of the code depends on the behavior of the libraries and functions we have included from the system. These functions, when called, each time bring different data to the system cache, causing the amount of data stored in RAM to vary. However, overall, it is about a range of 1 gigabyte consumed by our mentioned segment.</p><br />
<p>Now let's move on to the detailed explanations of the <code>time</code> command, which includes reports such as real, user, sys, and CPU, and see what they mean.</p><br />
<p><strong>Real Time</strong></p><br />
<p>It is the total time it took for the process to start and complete, as if we measured it with a stopwatch (or folks say with a wall clock). In technical terms, this time includes all the times spent, and represents the real time of a proccess from start to the end, including: the computation time, the times the process was waiting (blocked), and the times it was waiting for I/O.</p><br />
<p><strong>User Time</strong></p><br />
<p>It is the time that the CPU spent on this specific program calculations. In technical terms, it is the time when the process is sitting on the CPU and being executed (referred to as user mode).</p><br />
<p><strong>Sys Time</strong></p><br />
<p>It is the time the CPU spends on tasks performed by the operating system kernel realated the process, such as memory allocation and I/O operations (referred to as kernel mode).</p><br />
<p><strong>cpu</strong></p><br />
<p>And finally, this one is about how much of the CPU is allocated to this process. It might go beyond 100% (e.g. 650%) if you are running multi-threading, where multiple CPU cores are involved.</p><br />
<p>I mentioned the two execution modes of processes, user mode and kernel mode. These are modes of executing programs in Unix-like systems or any other memory-protected systems. There are differences between user mode and kernel mode, which I will try to explain briefly, and then I will provide a source for more detailed and specialized explanations:</p><br />
<p><strong>Kernel Mode</strong></p><br />
<p>If code is executed in this mode, that piece of code has complete and unrestricted access to the hardware. It can execute any system-call, such as any instruction for the CPU or interaction with any part of the memory. This is the highest level of access and happens at the lowest layer. It is risky if there is any misbehavior or issues in code running at this layer, as it can jeopardize the whole system. Therefore, the trusted system functions and APIs are executed in this mode.</p><br />
<p><strong>User Mode</strong></p><br />
<p>In contrast to the previous mode, in user mode, the program executor does not have direct access to the hardware and cannot interact directly with entities such as RAM and disks. Instead, it relies on an API provided by the operating system to interact and perform operations on its behalf. I will write an article later explaining the concept of an API. Therefore, this mode is more secure, and the code is isolated from the hardware, making it recoverable if any issues arise. Most of the codes executed in the system run in this mode.</p><br />
<p>References for this section:</p>
<ul>
<li><em><a href="https://blog.codinghorror.com/understanding-user-and-kernel-mode">https://blog.codinghorror.com/understanding-user-and-kernel-mode</a></em></li>
<li><em><a href="https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys">https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys</a></em></li>
<li><em><a href="https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems">https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems</a></em></li>
<li><em><a href="https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine">https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine</a></em></li>
<li><em><a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1</a></em></li>
</ul><br />
<p>Now we can have an estimate of the average time:</p>
<pre><code class="language-md">(2501.88+2440.13+2446.16+2444.35+2515.03+2438.22+2493.81+2501.99+2459.47+2429.63) / 10 = 24670.67 / 10 = 2467.067
(2501.97+2440.23+2446.23+2444.5+2515.09+2438.28+2493.94+2502.09+2460.05+2429.75) / 10 = 24672.13 / 10 = 2467.213
(1046800+1046864+1046772+1046848+1046832+1046844+1046784+1046852+1046872+1046772) / 10 = 10468240 / 10 = 1046824
(2.51s+2.45s+2.45s+2.45s+2.52s+2.45s+2.50s+2.51s+2.47s+2.43s) / 10 = 24.74 / 10 = 2.474
(2.36s+2.32s+2.32s+2.29s+2.39s+2.32s+2.35s+2.37s+2.32s+2.32s) / 10 = 23.36 / 10 = 2.336
(0.14s+0.13s+0.13s+0.16s+0.13s+0.12s+0.15s+0.14s+0.15s+0.12s) / 10 = 1.37 / 10 = 0.137
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2467.067 ms
* Average Execution Time(Based on chrono): 2467.213 ms
* Average Memory Usage: 1046824 KB
* Average Real Time: 2.474 s
* Average User Time: 2.336 s
* Average Sys Time: 0.137 s
* Average CPU Usage: 99 %</code></pre><br />
<p>Keep these results in mind for later comparison. This time order of storing data in random access memory (RAM) gives us the speed we need for comparison. In practice, this speed is marely equivalent to reading something from RAM in random access.</p><br />
<hr /><br />
<p>Now let's move on to the hard disk and see how much time/resources it takes to read/write one gigabyte of data on an HDD. However, in this comparison, we are no longer concerned about other resources like the amount of RAM it consumes, but rather its time is important to us. When we compare RAM to a disk, we no longer need to measure the RAM that undergoes I/O operations.</p><br />
<p>Consider the following code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    ofstream outfile;
    char character = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    outfile.open("output.txt");
    if (!outfile.is_open()) {
        cout &lt;&lt; "Error opening file!" &lt;&lt; endl;
        return 1;
    }
    for (int i = 0; i &lt; 1073741824; i++) {
        outfile &lt;&lt; character;
    }
    outfile.close();
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/HDD_write_test.cpp">Source code</a></p><br />
<p>This code opens a file named <code>output.txt</code> (creates it if it doesn't exist and overwrites it if it does {I'll return to the overwriting part later}) and writes 1 gigabyte of data into it. I will run it 10 times for the sake of experimentation:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ HDD_write_test.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out 
Execution Time (Based on ctime): 9536.65 ms
Execution Time (Based on chrono): 9538.49 ms
Memory Usage: 0 KB

real    9.54s
user    8.85s
sys     0.68s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9530.77 ms
Execution Time (Based on chrono): 10150.1 ms
Memory Usage: 0 KB

real    10.15s
user    8.82s
sys     0.72s
cpu     93%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9625.24 ms
Execution Time (Based on chrono): 10063.4 ms
Memory Usage: 0 KB

real    10.07s
user    8.99s
sys     0.64s
cpu     95%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9655.58 ms
Execution Time (Based on chrono): 9657.09 ms
Memory Usage: 0 KB

real    9.66s
user    8.96s
sys     0.70s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9479.76 ms
Execution Time (Based on chrono): 9634.6 ms
Memory Usage: 0 KB

real    9.64s
user    8.89s
sys     0.60s
cpu     98%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9477.25 ms
Execution Time (Based on chrono): 9641.66 ms
Memory Usage: 0 KB

real    9.65s
user    8.92s
sys     0.56s
cpu     98%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9468.07 ms
Execution Time (Based on chrono): 9475.96 ms
Memory Usage: 0 KB

real    9.48s
user    8.70s
sys     0.77s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9761.29 ms
Execution Time (Based on chrono): 10151.8 ms
Memory Usage: 0 KB

real    10.16s
user    9.05s
sys     0.72s
cpu     96%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9632.74 ms
Execution Time (Based on chrono): 10079 ms
Memory Usage: 0 KB

real    10.08s
user    8.92s
sys     0.72s
cpu     95%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 9536.97 ms
Execution Time (Based on chrono): 9540.68 ms
Memory Usage: 0 KB

real    9.55s
user    8.89s
sys     0.65s
cpu     99%</code></pre><br />
<p>And the average result of the experiment is:</p>
<pre><code class="language-md">(9536.65+9530.77+9625.24+9655.58+9479.76+9477.25+9468.07+9761.29+9632.74+9536.97) / 10 = 95704.32 / 10 = 9570.432
(9538.49+10150.1+10063.4+9657.09+9634.6+9641.66+9475.96+10151.8+10079+9540.68) / 10 = 97932.78 / 10 = 9793.278
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(9.54s+10.15s+10.07s+9.66s+9.64s+9.65s+9.48s+10.16s+10.08s+9.55s) / 10 = 97.98 / 10 = 9.798
(8.85s+8.82s+8.99s+8.96s+8.89s+8.92s+8.70s+9.05s+8.92s+8.89s) / 10 = 88.99 / 10 = 8.899
(0.68s+0.72s+0.64s+0.70s+0.60s+0.56s+0.77s+0.72s+0.72s+0.65s) / 10 = 6.76 / 10 = 0.676
(99%+93%+95%+99%+98%+98%+99%+96%+95%+99%) / 10 = 971 / 10 = 97.1


Therefore:

* Average Execution Time(Based on ctime): 9570.432 ms
* Average Execution Time(Based on chrono): 9793.278 ms
* Average Memory Usage: 0 KB
* Average Real Time: 9.798 s
* Average User Time: 8.899 s
* Average Sys Time: 0.676 s
* Average CPU Usage: 97.1 %</code></pre><br />
<p>Well, according to this HDD almost 5 times slower than RAM, isn't it?! So what was all that stuff about HDD being 10,000 times slower than RAM on average?! Don't rush, let's slowly add the factors involved in the experiment.<br />
Let's assume we want to overwrite existing 1 gigabyte of data.</p><br />
<hr /><br />
<p>To measure this operation time on RAM, I will modify the code as follows:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'B';    
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_overwrite_test.cpp">Source code</a></p><br />
<p>And we run the code:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ RAM_overwrite_test.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out              
Execution Time (Based on ctime): 2315.81 ms
Execution Time (Based on chrono): 2315.86 ms
Memory Usage: 0 KB

real    4.76s
user    4.61s
sys     0.14s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2321.07 ms
Execution Time (Based on chrono): 2321.15 ms
Memory Usage: 0 KB

real    4.80s
user    4.66s
sys     0.14s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2305.9 ms
Execution Time (Based on chrono): 2305.95 ms
Memory Usage: 0 KB

real    4.78s
user    4.67s
sys     0.11s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2331.96 ms
Execution Time (Based on chrono): 2332.03 ms
Memory Usage: 0 KB

real    4.79s
user    4.70s
sys     0.09s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2291.69 ms
Execution Time (Based on chrono): 2296.94 ms
Memory Usage: 0 KB

real    4.74s
user    4.57s
sys     0.16s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2336.1 ms
Execution Time (Based on chrono): 2339.92 ms
Memory Usage: 0 KB

real    4.85s
user    4.71s
sys     0.12s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2330.54 ms
Execution Time (Based on chrono): 2330.6 ms
Memory Usage: 0 KB

real    4.82s
user    4.70s
sys     0.12s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2283.55 ms
Execution Time (Based on chrono): 2283.58 ms
Memory Usage: 0 KB

real    4.72s
user    4.59s
sys     0.12s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2328.87 ms
Execution Time (Based on chrono): 2328.91 ms
Memory Usage: 0 KB

real    4.79s
user    4.67s
sys     0.12s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2295.38 ms
Execution Time (Based on chrono): 2296.14 ms
Memory Usage: 0 KB

real    4.75s
user    4.60s
sys     0.15s
cpu     99%</code></pre><br />
<p>And the average result:</p>
<pre><code class="language-md">(2315.81+2321.07+2305.9+2331.96+2291.69+2336.1+2330.54+2283.55+2328.87+2295.38) / 10 = 23140.87 / 10 = 2314.087
(2315.86+2321.15+2305.95+2332.03+2296.94+2339.92+2330.6+2283.58+2328.91+2296.14) / 10 = 23151.08 / 10 = 2315.108
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(4.76s+4.80s+4.78s+4.79s+4.74s+4.85s+4.82s+4.72s+4.79s+4.75s) / 10 = 47.8 / 10 = 4.78
(4.61s+4.66s+4.67s+4.70s+4.57s+4.71s+4.70s+4.59s+4.67s+4.60s) / 10 = 46.48 / 10 = 4.648
(0.14s+0.14s+0.11s+0.09s+0.16s+0.12s+0.12s+0.12s+0.12s+0.15s) / 10 = 1.27 / 10 = 0.127
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2314.087 ms
* Average Execution Time(Based on chrono): 2315.108 ms
* Average Memory Usage: 0 KB
* Average Real Time: 4.78 s
* Average User Time: 4.648 s
* Average Sys Time: 0.127 s
* Average CPU Usage: 99 %</code></pre><br />
<p>As you can see, the overwriting time is equal to the writing time.</p><br />
<p>Note 1: The specific part of the code we are measuring its time, is this specific segment of the code:</p>
<pre><code class="language-cpp">for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'B'; </code></pre><br />
<p>And the time is:</p>
<pre><code class="language-md">* Average Execution Time(Based on ctime): 2314.087 ms
* Average Execution Time(Based on chrono): 2315.108 ms</code></pre><br />
<p>Note 2: The amount of memory consumed by this code block is reported as 0 because we did not allocate any new memory (although we had, for example, a loop counter for 'i', but it is so small that it is not noticeable in kilobytes) - when we did not create new memory and only overwritten the previous one, no new memory usage was reported. But in reality, we worked with 1 gigabyte of memory.</p><br />
<p>Now let's move on to the hard disk. I will use the same previous code, but this time I will not delete (rm) the previously created 1-gigabyte files so that they can be overwritten.</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ HDD_write_test.cpp    

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out 
Execution Time (Based on ctime): 10162.1 ms
Execution Time (Based on chrono): 16532.7 ms
Memory Usage: 0 KB

real    16.54s
user    9.30s
sys     0.87s
cpu     61%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 9961.45 ms
Execution Time (Based on chrono): 19035.1 ms
Memory Usage: 0 KB

real    19.04s
user    9.10s
sys     0.86s
cpu     52%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 9925.02 ms
Execution Time (Based on chrono): 19885.7 ms
Memory Usage: 0 KB

real    19.89s
user    9.14s
sys     0.79s
cpu     49%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 9927.78 ms
Execution Time (Based on chrono): 20518.4 ms
Memory Usage: 0 KB

real    20.52s
user    9.04s
sys     0.89s
cpu     48%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 9996.59 ms
Execution Time (Based on chrono): 17915.4 ms
Memory Usage: 0 KB

real    17.92s
user    9.16s
sys     0.84s
cpu     55%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 9659.78 ms
Execution Time (Based on chrono): 19085.9 ms
Memory Usage: 0 KB

real    19.09s
user    8.91s
sys     0.76s
cpu     50%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 10051.7 ms
Execution Time (Based on chrono): 19261.9 ms
Memory Usage: 0 KB

real    19.27s
user    9.25s
sys     0.81s
cpu     52%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 10124.3 ms
Execution Time (Based on chrono): 19965.3 ms
Memory Usage: 0 KB

real    19.97s
user    9.31s
sys     0.82s
cpu     50%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 9867.27 ms
Execution Time (Based on chrono): 19433.7 ms
Memory Usage: 0 KB

real    19.44s
user    9.05s
sys     0.82s
cpu     50%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 9850.91 ms
Execution Time (Based on chrono): 18046 ms
Memory Usage: 0 KB

real    18.05s
user    8.96s
sys     0.89s
cpu     54%</code></pre><br />
<p>The average:</p>
<pre><code class="language-md">(10162.1+9961.45+9925.02+9927.78+9996.59+9659.78+10051.7+10124.3+9867.27+9850.91) / 10 = 99526.9 / 10 = 9952.69
(16532.7+19035.1+19885.7+20518.4+17915.4+19085.9+19261.9+19965.3+19433.7+18046) / 10 = 189680.1 / 10 = 18968.01
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(16.54s+19.04s+19.89s+20.52s+17.92s+19.09s+19.27s+19.97s+19.44s+18.05s) / 10 = 189.73 / 10 = 18.973
(9.30s+9.10s+9.14s+9.04s+9.16s+8.91s+9.25s+9.31s+9.05s+8.96s) / 10 = 91.22 / 10 = 9.122
(0.87s+0.86s+0.79s+0.89s+0.84s+0.76s+0.81s+0.82s+0.82s+0.89s) / 10 = 8.35 / 10 = 0.835
(61%+52%+49%+48%+55%+50%+52%+50%+50%+54%) / 10 = 521 / 10 = 52.1


Therefore:

* Average Execution Time(Based on ctime): 9952.69 ms
* Average Execution Time(Based on chrono): 18968.01 ms
* Average Memory Usage: 0 KB
* Average Real Time: 18.973 s
* Average User Time: 9.122 s
* Average Sys Time: 0.835 s
* Average CPU Usage: 52.1 %</code></pre><br />
<p>Awwwww! The result became 10 times slower. But wait, there's more to the story...</p><br />
<p>Note 1: Look at the execution time of the first HDD overwrite and compare it to the calculated average time. You will understand why I said each experiment should be repeated multiple times.</p><br />
<p>Note 2: As you can see, the time measured by "chrono" is much higher (almost twice) than the time measured by "ctime", and it represents the actual execution time of that code block. But why? It's similar to the real, user, and sys times I mentioned when discussing the <code>time</code> command. Scientifically, these two libraries calculate time using different methods. "ctime" is a library specific to the C language, and here it calculates time using the <code>clock()</code> function, but it's not the real time. it's the time the CPU spends on executing the current process. But that statement is not entirely accurate. Let me explain in a more technical language. ctime logs the number of clocks the CPU has executed for this specific program during its computations, and then converts these clocks into seconds. Simply put, it means it doesn't include the times like when we were performing I/O operations, or waiting for resources or I/O blocking, or waiting for other processes. Bui measuring the amount of I/O time is actually a significant part of our computations! "chrono" on the other hand, has a completely different story...<br />
The chrono library, when called on resolution methods (such as <code>high_resolution_clock</code>), calculates what is called the precise wall clock time, from the start point to the end point. This time includes interrupts and I/O operations. So this is the precise time that we use for comparing.</p><br />
<hr /><br />
<p>Now let's extend the scope of comparison a bit. Let's say we want to compare a simple copy-paste in RAM and in HDD. For RAM, consider the following code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    char* arr = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr[i] = 'A';

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    char* arr_2 = new char[1073741824];
    for(int i = 0; i &lt; 1073741824 ; i++)
        arr_2[i] = arr[i];    
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_copy_test.cpp">Source code</a></p><br />
<p>And let's jump right into execution:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ RAM_copy_test.cpp     

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2676.01 ms
Execution Time (Based on chrono): 2676.22 ms
Memory Usage: 1048824 KB

real    5.12s
user    4.89s
sys     0.23s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2616.64 ms
Execution Time (Based on chrono): 2616.71 ms
Memory Usage: 1048764 KB

real    5.06s
user    4.85s
sys     0.20s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2618.32 ms
Execution Time (Based on chrono): 2618.4 ms
Memory Usage: 1048712 KB

real    5.02s
user    4.81s
sys     0.20s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2616.12 ms
Execution Time (Based on chrono): 2616.2 ms
Memory Usage: 1048824 KB

real    5.05s
user    4.80s
sys     0.24s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2617.68 ms
Execution Time (Based on chrono): 2617.75 ms
Memory Usage: 1048824 KB

real    5.05s
user    4.88s
sys     0.17s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2620.01 ms
Execution Time (Based on chrono): 2620.11 ms
Memory Usage: 1048824 KB

real    5.06s
user    4.86s
sys     0.20s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2620.11 ms
Execution Time (Based on chrono): 2620.16 ms
Memory Usage: 1048824 KB

real    5.02s
user    4.79s
sys     0.23s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2615.65 ms
Execution Time (Based on chrono): 2615.84 ms
Memory Usage: 1048764 KB

real    5.03s
user    4.78s
sys     0.25s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2623.07 ms
Execution Time (Based on chrono): 2623.13 ms
Memory Usage: 1048780 KB

real    5.03s
user    4.86s
sys     0.17s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 2616.85 ms
Execution Time (Based on chrono): 2616.94 ms
Memory Usage: 1048780 KB

real    5.07s
user    4.87s
sys     0.20s
cpu     99%</code></pre><br />
<p>And the average:</p>
<pre><code class="language-md">(2676.01+2616.64+2618.32+2616.12+2617.68+2620.01+2620.11+2615.65+2623.07+2616.85) / 10 = 26240.46 / 10 = 2624.046
(2676.22+2616.71+2618.4+2616.2+2617.75+2620.11+2620.16+2615.84+2623.13+2616.94) / 10 = 26241.46 / 10 = 2624.146
(1048824+1048764+1048712+1048824+1048824+1048824+1048824+1048764+1048780+1048780) / 10 = 10487920 / 10 = 1048792
(5.12s+5.06s+5.02s+5.05s+5.05s+5.06s+5.02s+5.03s+5.03s+5.07s) / 10 = 50.51 / 10 = 5.051
(4.89s+4.85s+4.81s+4.80s+4.88s+4.86s+4.79s+4.78s+4.86s+4.87s) / 10 = 48.39 / 10 = 4.839
(0.23s+0.20s+0.20s+0.24s+0.17s+0.20s+0.23s+0.25s+0.17s+0.20s) / 10 = 2.09 / 10 = 0.209
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 2624.046 ms
* Average Execution Time(Based on chrono): 2624.146 ms
* Average Memory Usage: 1048792 KB
* Average Real Time: 5.051 s
* Average User Time: 4.839 s
* Average Sys Time: 0.209 s
* Average CPU Usage: 99 %</code></pre><br />
<hr /><br />
<p>Now let's copy that same 1 gigabyte of data from the disk, but to a different location on the same disk, let's say in another partition ^_^:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;

using namespace std;

int main() {

    char chunk;
    ifstream infile;
    ofstream outfile;

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------
    infile.open("output.txt");
    outfile.open("/media/user/MyDrive1/output_copy.txt");
    if (!outfile.is_open()) {
        cout &lt;&lt; "Error opening file!" &lt;&lt; endl;
        return 1;
    }
    while (infile.get(chunk))
        outfile.put(chunk);
    infile.close();
    outfile.close();
    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/HDD_copy_test.cpp">Source code</a></p><br />
<p>Execution:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ HDD_copy_test.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
Execution Time (Based on ctime): 18386.5 ms
Execution Time (Based on chrono): 25923.6 ms
Memory Usage: 0 KB

real    25.93s
user    16.58s
sys     1.81s
cpu     70%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; !!

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 17681.3 ms
Execution Time (Based on chrono): 23741.9 ms
Memory Usage: 0 KB

real    23.74s
user    15.98s
sys     1.70s
cpu     74%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out
Execution Time (Based on ctime): 17245.1 ms
Execution Time (Based on chrono): 24897.7 ms
Memory Usage: 0 KB

real    24.90s
user    15.49s
sys     1.76s
cpu     69%


‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt      
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1874 s, 105 MB/s

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 19407.6 ms
Execution Time (Based on chrono): 33033.6 ms
Memory Usage: 0 KB

real    33.04s
user    17.42s
sys     1.99s
cpu     58%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.4907 s, 102 MB/s

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20163.5 ms
Execution Time (Based on chrono): 36565.9 ms
Memory Usage: 0 KB

real    36.57s
user    18.03s
sys     2.13s
cpu     55%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1993 s, 105 MB/s

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20450.9 ms
Execution Time (Based on chrono): 38170.3 ms
Memory Usage: 0 KB

real    38.17s
user    18.30s
sys     2.15s
cpu     53%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1726 s, 106 MB/s

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20228.9 ms
Execution Time (Based on chrono): 33791.1 ms
Memory Usage: 0 KB

real    33.79s
user    18.12s
sys     2.11s
cpu     59%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.2377 s, 105 MB/s

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 20001.4 ms
Execution Time (Based on chrono): 35478 ms
Memory Usage: 0 KB

real    35.48s
user    17.79s
sys     2.21s
cpu     56%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.5428 s, 102 MB/s

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 19954.7 ms
Execution Time (Based on chrono): 34560.4 ms
Memory Usage: 0 KB

real    34.56s
user    17.55s
sys     2.41s
cpu     57%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt
1048576+0 records in
1048576+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.1674 s, 106 MB/s

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ rm /media/user/MyDrive1/output_copy.txt &amp;&amp; time ./a.out              
Execution Time (Based on ctime): 21618.5 ms
Execution Time (Based on chrono): 39370.6 ms
Memory Usage: 0 KB

real    39.37s
user    19.18s
sys     2.44s
cpu     54%</code></pre><br />
<p>Average time:</p>
<pre><code class="language-md">(18386.5+17681.3+17245.1+19407.6+20163.5+20450.9+20228.9+20001.4+19954.7+21618.5) / 10 = 195138.4 / 10 = 19513.84
(25923.6+23741.9+24897.7+33033.6+36565.9+38170.3+33791.1+35478+34560.4+39370.6) / 10 = 325533.1 / 10 = 32553.31
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(25.93s+23.74s+24.90s+33.04s+36.57s+38.17s+33.79s+35.48s+34.56s+39.37s) / 10 = 325.55 / 10 = 32.555
(16.58s+15.98s+15.49s+17.42s+18.03s+18.30s+18.12s+17.79s+17.55s+19.18s) / 10 = 174.44 / 10 = 17.444
(1.81s+1.70s+1.76s+1.99s+2.13s+2.15s+2.11s+2.21s+2.41s+2.44s) / 10 = 20.71 / 10 = 2.071
(70%+74%+69%+58%+55%+53%+59%+56%+57%+54%) / 10 = 605 / 10 = 60.5


Therefore:

* Average Execution Time(Based on ctime): 19513.84 ms
* Average Execution Time(Based on chrono): 32553.31 ms
* Average Memory Usage: 0 KB
* Average Real Time: 32.555 s
* Average User Time: 17.444 s
* Average Sys Time: 2.071 s
* Average CPU Usage: 60.5 %</code></pre><br />
<p>Here, I performed a subtle trick:))</p><br />
<p>I'll explain it in technical language only. By ovserving files getting copied quickly within a range of 20 seconds, I realized that an optimization is goin on under the hood. It's possible that the file has been cached by an entity - the operating system or I/O-related API modules - (and we can see how practical concepts are approving theoretical ones). And since the file entropy is very low (because it's all full of ASCII bytes of "A" character), our experiment may be influenced by the optimizations I explained earlier theoretically. Therefore, for this purpose, I obtained 1 gigabyte of random data from the system entropy instead of our low-entropy file and observed that the time became much longer (up to 20 times longer).</p>
<pre><code class="language-bash">rm output.txt &amp;&amp; dd if=/dev/random bs=1024 count=1048576 &gt; output.txt</code></pre><br />
<hr /><br />
<p>I want to do the final comparing and change the workflow. For this matter, we compare HDD and RAM in a way that several processes consume resources in parallel and interact directly with the hard disk or RAM. We want to see how the servicing time decreases when our storage device is under shared access, both in RAM and disk.</p><br />
<p>From what we discussed in theory, we know that RAM shouldn't really make much of difference in its behaviour and its speed is not heavily affected by this matter, so it shouldn't slow down significantly. However, the disk on the other hand, due to its physical movements, is likely to be severely affected in terms of speed. Let's go and see it in practice:</p><br />
<p>The following program eats the RAM! It takes 1 gigabyte of RAM and repeatedly refills and makes it empty.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    cout &lt;&lt; "EATING RAM!!!" &lt;&lt; endl;
    while( true )
    {
        char* arr = new char[1073741824];
        for(int i = 0; i &lt; 1073741824 ; i++)
            arr[i] = 'A';
        delete arr;
    }

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_eater_test.cpp">Source code</a></p><br />
<p>I run four instances of this program in parallel at the same time:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ RAM_eater.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./a.out
EATING RAM!!!</code></pre>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./a.out
EATING RAM!!!</code></pre>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./a.out
EATING RAM!!!</code></pre>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./a.out
EATING RAM!!!</code></pre><br />
<p><img src="Files/Executing_RAMeaters.png" alt="Executing RAM-eaters" /></p><br />
<p>And the output of the <code>top</code> command when four instances of the memory-consuming process are running:</p><br />
<p><img src="Files/top_command_result.png" alt="top command result" /></p><br />
<p>Now, concurrently with these, I run our first program, which is <a href="./Files/RAM_write_test.cpp">this</a>:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ RAM_write_test.cpp -o test.out

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out                   
Execution Time (Based on ctime): 3638.12 ms
Execution Time (Based on chrono): 3638.24 ms
Memory Usage: 1047004 KB

real    3.67s
user    3.45s
sys     0.22s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3539.23 ms
Execution Time (Based on chrono): 3539.71 ms
Memory Usage: 1046948 KB

real    3.56s
user    3.36s
sys     0.20s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3587.88 ms
Execution Time (Based on chrono): 3588.17 ms
Memory Usage: 1046956 KB

real    3.63s
user    3.43s
sys     0.20s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3629.68 ms
Execution Time (Based on chrono): 3630.07 ms
Memory Usage: 1046968 KB

real    3.67s
user    3.43s
sys     0.24s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3568.61 ms
Execution Time (Based on chrono): 3568.84 ms
Memory Usage: 1046920 KB

real    3.59s
user    3.39s
sys     0.21s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3578.81 ms
Execution Time (Based on chrono): 3578.97 ms
Memory Usage: 1046828 KB

real    3.61s
user    3.39s
sys     0.22s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3585.52 ms
Execution Time (Based on chrono): 3585.62 ms
Memory Usage: 1046760 KB

real    3.61s
user    3.33s
sys     0.28s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3566.91 ms
Execution Time (Based on chrono): 3567.07 ms
Memory Usage: 1046944 KB

real    3.60s
user    3.37s
sys     0.22s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3594.36 ms
Execution Time (Based on chrono): 3594.45 ms
Memory Usage: 1046972 KB

real    3.63s
user    3.39s
sys     0.24s
cpu     99%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./test.out
Execution Time (Based on ctime): 3584.68 ms
Execution Time (Based on chrono): 3588.76 ms
Memory Usage: 1046840 KB

real    3.62s
user    3.35s
sys     0.27s
cpu     99%</code></pre><br />
<p>And Calculating average:</p>
<pre><code class="language-md">(3638.12+3539.23+3587.88+3629.68+3568.61+3578.81+3585.52+3566.91+3594.36+3584.68) / 10 = 35873.8 / 10 = 3587.38
(3638.24+3539.71+3588.17+3630.07+3568.84+3578.97+3585.62+3567.07+3594.45+3588.76) / 10 = 35879.9 / 10 = 3587.99
(1047004+1046948+1046956+1046968+1046920+1046828+1046760+1046944+1046972+1046840) / 10 = 10469140 / 10 = 1046914
(3.67s+3.56s+3.63s+3.67s+3.59s+3.61s+3.61s+3.60s+3.63s+3.62s) / 10 = 36.19 / 10 = 3.619
(3.45s+3.36s+3.43s+3.43s+3.39s+3.39s+3.33s+3.37s+3.39s+3.35s) / 10 = 33.89 / 10 = 3.389
(0.22s+0.20s+0.20s+0.24s+0.21s+0.22s+0.28s+0.22s+0.24s+0.27s) / 10 = 2.3 / 10 = 0.23
(99%+99%+99%+99%+99%+99%+99%+99%+99%+99%) / 10 = 990 / 10 = 99


Therefore:

* Average Execution Time(Based on ctime): 3587.38 ms
* Average Execution Time(Based on chrono): 3587.99 ms
* Average Memory Usage: 1046914 KB
* Average Real Time: 3.619 s
* Average User Time: 3.389 s
* Average Sys Time: 0.23 s
* Average CPU Usage: 99 %</code></pre><br />
<p>We can see that the average time has increased approximately by 1.5 times. However, this increase in time does not necessarily mean that the RAM chips have become slower. It could be due to the congestion of the RAM bus, the congestion of the operating system's RAM module, the congestion of the API that processes interact with for memory allocation, or even the congestion of the processor itself!<br />
To make sure it's not because of the processor, I repeat the above experiment in a multithreading or multicore manner, and I put each memory-consuming process on a separate core of the CPU, and also put the test process on a separate core (altogether 5 cores).<br />
In simple terms, a multithreaded program assigns different computation threads to different cores. With this approach, we can ensure that the slowdown is not only due to CPU congestion... (Later, we will discuss multithreading or multiprocessing in detail in an article.)</p><br />
<hr /><br />
<p>Consider the following program:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std;

void ram_eater()
{
    cout &lt;&lt; "A ram-eater started eating!" &lt;&lt; endl;
    while( true )
    {
        char* arr = new char[1073741824];
        for(int i = 0; i &lt; 1073741824 ; i++)
            arr[i] = 'A';
        delete arr;
    }
}

void test()
{
    for( int i = 0; i &lt; 10; i++ )
    {
        // Start execution time
        clock_t start_1 = clock();
        auto start_2 = chrono::high_resolution_clock::now();

        // Start memory usage
        struct rusage usage;
        getrusage(RUSAGE_SELF, &amp;usage);
        long memory_usage_start = usage.ru_maxrss; // in kilobytes

        // Code ----------------------------------------------------------
        char* arr = new char[1073741824];
        for(int j = 0; j &lt; 1073741824 ; j++)
            arr[j] = 'A';

        // ---------------------------------------------------------------

        // Stop measuring memory usage
        getrusage(RUSAGE_SELF, &amp;usage);
        long memory_usage_end = usage.ru_maxrss; // in kilobytes

        // Stop measuring execution time
        clock_t end_1 = clock();
        auto end_2 = chrono::high_resolution_clock::now();
        double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
        chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

        // Printing result
        cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
        cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
        cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

        // Free memory to prevent memory-leak
        delete arr;

        // Sleep for 10 seconds
        this_thread::sleep_for(chrono::milliseconds(10000)); 
    }
}

int main() {
    vector&lt;thread&gt; threads;

    threads.emplace_back(ram_eater);
    threads.emplace_back(ram_eater);
    threads.emplace_back(ram_eater);
    threads.emplace_back(ram_eater);

    threads.emplace_back(test);

    // Wait for test to be over
    threads[4].join();

    return 0;
}</code></pre><br />
<p><a href="./Files/RAM_eating_multithreading_test.cpp">Source code</a></p><br />
<p>Execution:</p><br />
<p><img src="Files/Executing_RAM_eating_multithreading_test.png" alt="Executing RAM_eating_multithreading_test.cpp" /></p>
<pre><code class="language-diff">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ RAM_eating_multithreading_test.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./a.out                               
A ram-eater started eating!
A ram-eater started eating!
A ram-eater started eating!
A ram-eater started eating!
Execution Time (Based on ctime): 12877.4 ms
-Execution Time (Based on chrono): 2576.37 ms
Memory Usage: 4595268 KB
Execution Time (Based on ctime): 14381.2 ms
-Execution Time (Based on chrono): 2879.22 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18355.6 ms
-Execution Time (Based on chrono): 3672.86 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18452.8 ms
-Execution Time (Based on chrono): 3692.51 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 17189.4 ms
-Execution Time (Based on chrono): 3442.85 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18136.1 ms
-Execution Time (Based on chrono): 3625.81 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 17982.1 ms
-Execution Time (Based on chrono): 3599.67 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18238.8 ms
-Execution Time (Based on chrono): 3648.24 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18639.8 ms
-Execution Time (Based on chrono): 3729.46 ms
Memory Usage: 0 KB
Execution Time (Based on ctime): 18598.2 ms
-Execution Time (Based on chrono): 3719.59 ms
Memory Usage: 0 KB
terminate called without an active exception
zsh: IOT instruction  ./a.out</code></pre><br />
<p>You see that the program is running on multiple cores, and since everything is under one process, the <code>ctime</code> reported time and the amount of memory consumed by the irrelevant data are not relevant to our experiment. Only the <code>chrono</code> time, marked in red (as a Markdown symbol), is the accurate time that should be involved in the comparison. The average time is as follows:</p>
<pre><code class="language-md">(2576.37+2879.22+3672.86+3692.51+3442.85+3625.81+3599.67+3648.24+3729.46+3719.59) / 10 = 34586.58 / 10 = 3458.658

Therefore:

* Average Execution Time(Based on chrono): 3458.658 ms</code></pre><br />
<p>The average time obtained in a multithreaded manner is <code>3458.658</code> milliseconds, which is approximately equal to the average time of multiprocessing, which is <code>3587.99</code> milliseconds. So, we can confidently say that, on average, by allocating 100 milliseconds to processor overhead, RAM under a Unix system, during shared access - in a deadly manner! - becomes only 1.5 times slower.</p><br />
<hr /><br />
<p>Now let's move on to the same shared access on the hard disk. For this purpose, we are writing a disk-consuming program:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;signal.h&gt;
#include &lt;ctime&gt;

using namespace std;

ofstream outfile;

void signalHandler(int signum) {
    outfile.close();
    cout &lt;&lt; "Interrupt signal received. File closed." &lt;&lt; endl;
    exit(signum);
}

int main() {
    signal(SIGINT, signalHandler);
    srand(time(NULL));
    char character = 'A';
    string filename = to_string(rand()) + ".txt";

    cout &lt;&lt; "EATING HDD!!!" &lt;&lt; endl;


    while (true) {

        outfile.open(filename);
        if (!outfile.is_open()) {
            cout &lt;&lt; "Error opening file: " &lt;&lt; filename &lt;&lt; endl;
            return 1;
        }

        for (int i = 0; i &lt; 1073741824; i++) {
            outfile &lt;&lt; character;
        }

        outfile.close();
    }

    return 0;
}</code></pre><br />
<p><a href="./Files/HDD_eater.cpp">Source code</a></p><br />
<p>Let me give you a brief explanation. This program creates a file with random names and writes 1 gigabyte of data into it. When the writing process is complete, it starts over and writes from the beginning again. This process continues indefinitely unless a interrup-signal is sent to the program. Upon receiving the interruption, it closes the file and the program finishes.</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ HDD_eater.cpp -o HDD_eater.out

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./HDD_eater.out 
EATING HDD!!!</code></pre>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./HDD_eater.out 
EATING HDD!!!</code></pre>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./HDD_eater.out 
EATING HDD!!!</code></pre>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ ./HDD_eater.out 
EATING HDD!!!</code></pre><br />
<p><img src="Files/Executing_HDDeaters.png" alt="Executing HDD-eaters" /></p><br />
<p>And during this process, I am running <a href="./Files/HDD_write_test.cpp">this</a> program:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ HDD_write_test.cpp -o HDD_write.out

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out 
Execution Time (Based on ctime): 11230.8 ms
Execution Time (Based on chrono): 25468.1 ms
Memory Usage: 0 KB

real    25.48s
user    10.30s
sys     0.93s
cpu     44%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 11096.1 ms
Execution Time (Based on chrono): 20764 ms
Memory Usage: 0 KB

real    20.77s
user    10.16s
sys     0.94s
cpu     53%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 13815.2 ms
Execution Time (Based on chrono): 32682 ms
Memory Usage: 0 KB

real    32.68s
user    12.63s
sys     1.18s
cpu     42%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 15544.6 ms
Execution Time (Based on chrono): 47560 ms
Memory Usage: 0 KB

real    47.57s
user    13.91s
sys     1.64s
cpu     32%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 16873.7 ms
Execution Time (Based on chrono): 45354.9 ms
Memory Usage: 0 KB

real    45.36s
user    15.25s
sys     1.63s
cpu     37%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 15391.3 ms
Execution Time (Based on chrono): 39712.6 ms
Memory Usage: 0 KB

real    39.92s
user    13.94s
sys     1.46s
cpu     38%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 14051.7 ms
Execution Time (Based on chrono): 29361.3 ms
Memory Usage: 0 KB

real    29.36s
user    12.61s
sys     1.44s
cpu     47%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 13137.5 ms
Execution Time (Based on chrono): 35374 ms
Memory Usage: 0 KB

real    35.64s
user    11.94s
sys     1.21s
cpu     36%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 13510.7 ms
Execution Time (Based on chrono): 28392.7 ms
Memory Usage: 0 KB

real    28.40s
user    12.42s
sys     1.10s
cpu     47%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 13595 ms
Execution Time (Based on chrono): 44944.2 ms
Memory Usage: 0 KB

real    44.95s
user    12.24s
sys     1.35s
cpu     30%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 18275.6 ms
Execution Time (Based on chrono): 70660.9 ms
Memory Usage: 0 KB

real    70.66s
user    16.16s
sys     2.11s
cpu     25%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 17255 ms
Execution Time (Based on chrono): 49479.4 ms
Memory Usage: 0 KB

real    49.48s
user    15.43s
sys     1.82s
cpu     34%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 15195.9 ms
Execution Time (Based on chrono): 52613.5 ms
Memory Usage: 0 KB

real    52.62s
user    13.64s
sys     1.56s
cpu     28%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 14688.6 ms
Execution Time (Based on chrono): 54965.7 ms
Memory Usage: 0 KB

real    54.97s
user    13.33s
sys     1.36s
cpu     26%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 18287.1 ms
Execution Time (Based on chrono): 61944 ms
Memory Usage: 0 KB

real    61.95s
user    16.30s
sys     1.98s
cpu     29%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 21118.9 ms
Execution Time (Based on chrono): 70709.4 ms
Memory Usage: 0 KB

real    70.71s
user    19.07s
sys     2.05s
cpu     29%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 24345 ms
Execution Time (Based on chrono): 82900.9 ms
Memory Usage: 0 KB

real    82.90s
user    21.94s
sys     2.41s
cpu     29%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 18640.5 ms
Execution Time (Based on chrono): 56225.7 ms
Memory Usage: 0 KB

real    56.23s
user    16.70s
sys     1.94s
cpu     33%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 17671.1 ms
Execution Time (Based on chrono): 68766 ms
Memory Usage: 0 KB

real    68.77s
user    16.09s
sys     1.58s
cpu     25%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./HDD_write.out
Execution Time (Based on ctime): 22847.9 ms
Execution Time (Based on chrono): 88525.2 ms
Memory Usage: 0 KB

real    88.53s
user    20.43s
sys     2.42s
cpu     25%</code></pre>
<pre><code class="language-md">(11230.8+11096.1+13815.2+15544.6+16873.7+15391.3+14051.7+13137.5+13510.7+13595+18275.6+17255+15195.9+14688.6+18287.1+21118.9+24345+18640.5+17671.1+22847.9) / 20 = 326572.2 / 20 = 16328.61
(25468.1+20764+32682+47560+45354.9+39712.6+29361.3+35374+28392.7+44944.2+70660.9+49479.4+52613.5+54965.7+61944+70709.4+82900.9+56225.7+68766+88525.2) / 20 = 1006404.5 / 20 = 50320.225
(0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0) / 20 = 0 / 20 = 0
(25.48s+20.77s+32.68s+47.57s+45.36s+39.92s+29.36s+35.64s+28.40s+44.95s+70.66s+49.48s+52.62s+54.97s+61.95s+70.71s+82.90s+56.23s+68.77s+88.53s) / 20 = 1006.95 / 20 = 50.3475
(10.30s+10.16s+12.63s+13.91s+15.25s+13.94s+12.61s+11.94s+12.42s+12.24s+16.16s+15.43s+13.64s+13.33s+16.30s+19.07s+21.94s+16.70s+16.09s+20.43s) / 20 = 294.49 / 20 = 14.7245
(0.93s+0.94s+1.18s+1.64s+1.63s+1.46s+1.44s+1.21s+1.10s+1.35s+2.11s+1.82s+1.56s+1.36s+1.98s+2.05s+2.41s+1.94s+1.58s+2.42s) / 20 = 32.11 / 20 = 1.6055
(44%+53%+42%+32%+37%+38%+47%+36%+47%+30%+25%+34%+28%+26%+29%+29%+29%+33%+25%+25%) / 20 = 689 / 20 = 34.45


Therefore:

* Average Execution Time(Based on ctime): 16328.61 ms
* Average Execution Time(Based on chrono): 50320.225 ms
* Average Memory Usage: 0 KB
* Average Real Time: 50.3475 s
* Average User Time: 14.7245 s
* Average Sys Time: 1.6055 s
* Average CPU Usage: 34.45 %</code></pre><br />
<p>Take a look at this chart, in the first 20 experiments, the time duration has become slower in this way:</p><br />
<p><img src="Files/HDD_speed_chart_in_20_tests.png" alt="HDD speed chart in 20 tests" /></p>
<table>
<thead>
<tr>
<th>Test#</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>25468.1</td>
</tr>
<tr>
<td>2</td>
<td>20764</td>
</tr>
<tr>
<td>3</td>
<td>32682</td>
</tr>
<tr>
<td>4</td>
<td>47560</td>
</tr>
<tr>
<td>5</td>
<td>45354.9</td>
</tr>
<tr>
<td>6</td>
<td>39712.6</td>
</tr>
<tr>
<td>7</td>
<td>29361.3</td>
</tr>
<tr>
<td>8</td>
<td>35374</td>
</tr>
<tr>
<td>9</td>
<td>28392.7</td>
</tr>
<tr>
<td>10</td>
<td>44944.2</td>
</tr>
<tr>
<td>11</td>
<td>70660.9</td>
</tr>
<tr>
<td>12</td>
<td>49479.4</td>
</tr>
<tr>
<td>13</td>
<td>52613.5</td>
</tr>
<tr>
<td>14</td>
<td>54965.7</td>
</tr>
<tr>
<td>15</td>
<td>61944</td>
</tr>
<tr>
<td>16</td>
<td>70709.4</td>
</tr>
<tr>
<td>17</td>
<td>82900.9</td>
</tr>
<tr>
<td>18</td>
<td>56225.7</td>
</tr>
<tr>
<td>19</td>
<td>68766</td>
</tr>
<tr>
<td>20</td>
<td>88525.2</td>
</tr>
</tbody>
</table><br />
<p>Note: I created this chart using the free and open-source software <code>LibreOffice</code>.</p><br />
<p>Firstly, what is observable from the chart is that over time, there is a linear growth in the time taken for I/O on the disk during shared access. We can conclude that as time passes, the disk writing time becomes slower and slower, unlike RAM, which follows a consistent trend.</p><br />
<p>Secondly, we can see that the disk has performed its job 50 times slower, but we expected it to be much slower. This is related to the optimizations made by the operating system. The operating system does not allow one process to monopolize I/O on the disk, preventing other processes from accessing it. Instead, it schedules them in turns on the processor and shares the shared-resources. For more information, you can study the concepts of "deadlock" and "mutual exclusion" in computing. We may discuss them in separate article later.</p><br />
<p>Thirdly, the optimization in the operating system is not the entire issue. Our HDD-eaters are not really standard. They are just four processes that write a limited and constant amount of data (which can be cached) in sequential sectors of the disk, repeating this movement. What if, instead of these HDD-eaters, we used real ones?</p><br />
<hr /><br />
<p>Alright, that's enough for now. I'll stop this experiment here because I don't want to damage my disk! But this story will remain unfinished:</p>
<ul>
<li>What other scenarios can we test to compare HDD and RAM in large datas?</li>
</ul><br />
<p>The comparison we made was a one-dimensional comparison. It was solely about a bunch of data being written in the most optimal way on the HDD/RAM, and we could observe that it could be up to 80 times slower in different scenarios. However, this experimental setup and comparison do not cover all aspects of the situation. We need another dimension of comparison.</p><br />
<p>Stay tuned for the article as we move on to the second phase of comparison...</p><br />
<hr /><br />
<h3>Phase Two: Comparing the Speed of RAM and Hard Disk for Small Data and Fast Sequential Allocations</h3><br />
<p>In this phase, we measure and compare the time spent for computation that are typically uses RAM for storage, once on RAM and once on the hard disk (how?!). In simple terms, we compare the speed of a specific computation, which is usually performed on RAM, with the speed of the same computation under the condition that it uses the hard disk for storage instead of RAM!</p><br />
<p>Consider the following code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;
using namespace std;

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------

    unsigned long long n = 94, t1 = 0, t2 = 1, t3 = 0;

    if(n == 1)
        cout &lt;&lt; t1 &lt;&lt; endl;
    else if(n == 2)
        cout &lt;&lt; t2 &lt;&lt; endl;
    else{
        unsigned long long counter = 3;
        while (counter &lt;= n) {
            t3 = t1 + t2;
            t1 = t2;
            t2 = t3;
            ++counter;
        }
        cout &lt;&lt; t3 &lt;&lt; endl;
    }

    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/Fibo_RAM.cpp">Source code</a></p><br />
<p>This code returns the nth term of the well-known Fibonacci sequence. The Fibonacci sequence is a famous mathematical example that is often used to explain many programming concepts. It is defined as follows: </p><br />
<p>Each term is the sum of the two precvious terms, assuming the first term is <code>0</code> and the second term is <code>1</code>:</p>
<pre><code class="language-md">0,1,1,2,3,5,8,13,21,34,55,89,‚Ä¶</code></pre><br />
<p>This code can calculate Fibonacci terms up to the 94th term. However, beyond that, it overflows due to the size of <code>long long</code>, which is 8 bytes (64 bits). When it exceeds 2 to the power of 64, which is <code>18446744073709551616</code>, it overflows and produces incorrect results (read about big numbers. Hint: Big-Int).</p><br />
<p>In this code, we have stored all variables solely in RAM. Now let's see its execution time:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ Fibo_RAM.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out    
12200160415121876738
Execution Time (Based on ctime): 0.066 ms
Execution Time (Based on chrono): 0.035751 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.127 ms
Execution Time (Based on chrono): 0.094721 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.01s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.122 ms
Execution Time (Based on chrono): 0.08808 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.05 ms
Execution Time (Based on chrono): 0.034632 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.15 ms
Execution Time (Based on chrono): 0.111781 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.14 ms
Execution Time (Based on chrono): 0.101224 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.15 ms
Execution Time (Based on chrono): 0.111455 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.048 ms
Execution Time (Based on chrono): 0.032223 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.053 ms
Execution Time (Based on chrono): 0.037364 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.046 ms
Execution Time (Based on chrono): 0.030818 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.125 ms
Execution Time (Based on chrono): 0.09257 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.12 ms
Execution Time (Based on chrono): 0.088397 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.121 ms
Execution Time (Based on chrono): 0.089428 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.159 ms
Execution Time (Based on chrono): 0.111137 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.01s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.148 ms
Execution Time (Based on chrono): 0.110892 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.053 ms
Execution Time (Based on chrono): 0.03688 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.129 ms
Execution Time (Based on chrono): 0.096686 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.01s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.044 ms
Execution Time (Based on chrono): 0.029967 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.045 ms
Execution Time (Based on chrono): 0.029736 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.128 ms
Execution Time (Based on chrono): 0.094682 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.121 ms
Execution Time (Based on chrono): 0.088579 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.103 ms
Execution Time (Based on chrono): 0.051734 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.047 ms
Execution Time (Based on chrono): 0.030919 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.145 ms
Execution Time (Based on chrono): 0.106697 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.051 ms
Execution Time (Based on chrono): 0.034342 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.148 ms
Execution Time (Based on chrono): 0.110057 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.126 ms
Execution Time (Based on chrono): 0.094865 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.01s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.051 ms
Execution Time (Based on chrono): 0.035199 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.14 ms
Execution Time (Based on chrono): 0.102388 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.01s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.045 ms
Execution Time (Based on chrono): 0.030435 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     85%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.048 ms
Execution Time (Based on chrono): 0.034097 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     85%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.124 ms
Execution Time (Based on chrono): 0.092128 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.046 ms
Execution Time (Based on chrono): 0.031791 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.045 ms
Execution Time (Based on chrono): 0.030651 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.046 ms
Execution Time (Based on chrono): 0.031053 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.06 ms
Execution Time (Based on chrono): 0.045026 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.047 ms
Execution Time (Based on chrono): 0.031791 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.129 ms
Execution Time (Based on chrono): 0.095468 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.122 ms
Execution Time (Based on chrono): 0.087091 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.044 ms
Execution Time (Based on chrono): 0.029332 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out         
12200160415121876738
Execution Time (Based on ctime): 0.13 ms
Execution Time (Based on chrono): 0.096376 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.125 ms
Execution Time (Based on chrono): 0.091047 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.124 ms
Execution Time (Based on chrono): 0.090338 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.124 ms
Execution Time (Based on chrono): 0.090225 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.121 ms
Execution Time (Based on chrono): 0.0879 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.124 ms
Execution Time (Based on chrono): 0.091002 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     89%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.127 ms
Execution Time (Based on chrono): 0.093424 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     87%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.123 ms
Execution Time (Based on chrono): 0.090351 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.01s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.136 ms
Execution Time (Based on chrono): 0.103215 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     88%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 0.118 ms
Execution Time (Based on chrono): 0.085639 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     88%</code></pre><br />
<p>Because the reported time intervals were bloody small, I increased the number of executions for different time intervals (50 times) to have a more accurate estimate of the average time:</p>
<pre><code class="language-md">(0.066+0.127+0.122+0.05+0.15+0.14+0.15+0.048+0.053+0.046+0.125+0.12+0.121+0.159+0.148+0.053+0.129+0.044+0.045+0.128+0.121+0.103+0.047+0.145+0.051+0.148+0.126+0.051+0.14+0.045+0.048+0.124+0.046+0.045+0.046+0.06+0.047+0.129+0.122+0.044+0.13+0.125+0.124+0.124+0.121+0.124+0.127+0.123+0.136+0.118) / 50 = 4.964 / 50 = 0.09928
(0.035751+0.094721+0.08808+0.034632+0.111781+0.101224+0.111455+0.032223+0.037364+0.030818+0.09257+0.088397+0.089428+0.111137+0.110892+0.03688+0.096686+0.029967+0.029736+0.094682+0.088579+0.051734+0.030919+0.106697+0.034342+0.110057+0.094865+0.035199+0.102388+0.030435+0.034097+0.092128+0.031791+0.030651+0.031053+0.045026+0.031791+0.095468+0.087091+0.029332+0.096376+0.091047+0.090338+0.090225+0.0879+0.091002+0.093424+0.090351+0.103215+0.085639) / 50 = 3.571584 / 50 = 0.07143168
(0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0) / 50 = 0 / 50 = 0
(0.00s+0.01s+0.01s+0.00s+0.01s+0.01s+0.01s+0.00s+0.00s+0.00s+0.01s+0.01s+0.01s+0.01s+0.01s+0.00s+0.01s+0.00s+0.00s+0.01s+0.01s+0.00s+0.00s+0.01s+0.00s+0.01s+0.01s+0.00s+0.01s+0.00s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.01s+0.00s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s) / 50 = 0.3 / 50 = 0.006
(0.00s+0.00s+0.00s+0.00s+0.01s+0.01s+0.00s+0.00s+0.00s+0.00s+0.01s+0.01s+0.00s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.00s+0.00s+0.00s) / 50 = 0.07 / 50 = 0.0014
(0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.00s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.00s+0.00s) / 50 = 0.06 / 50 = 0.0012
(87%+88%+88%+89%+88%+88%+89%+86%+88%+87%+87%+88%+87%+88%+88%+89%+88%+86%+86%+89%+86%+89%+88%+89%+88%+89%+88%+89%+89%+85%+85%+87%+88%+86%+86%+87%+88%+89%+89%+86%+88%+89%+87%+88%+88%+89%+87%+88%+88%+88%) / 50 = 4385 / 50 = 87.7


Therefore:

* Average Execution Time(Based on ctime): 0.09928 ms
* Average Execution Time(Based on chrono): 0.07143168 ms
* Average Memory Usage: 0 KB
* Average Real Time: 0.006 s
* Average User Time: 0.0014 s
* Average Sys Time: 0.0012 s
* Average CPU Usage: 87.7 %</code></pre><br />
<p>Now let's write the same program in a way that stores the variables it uses on the disk instead of RAM!</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

void set_unsigned_long_long_variable(string name, unsigned long long var)
{
    ofstream outfile(name + ".bin"  , ofstream::binary);
    if (outfile)
    {
        outfile.write(reinterpret_cast&lt;const char*&gt;(&amp;var), sizeof(var));
        outfile.close();
    }
    else cerr &lt;&lt; "Error opening file: " &lt;&lt; name + ".bin" &lt;&lt; endl;
}

unsigned long long get_unsigned_long_long_variable(string name)
{
    unsigned long long var = 0;
    ifstream infile(name + ".bin", ifstream::binary);
    if (infile)
    {
        infile.read(reinterpret_cast&lt;char*&gt;(&amp;var), sizeof(var));
        infile.close();
    }
    else cerr &lt;&lt; "Error opening file: " &lt;&lt; name + ".bin" &lt;&lt; endl;

    return var;
}

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------

    set_unsigned_long_long_variable( "n", 94 );
    set_unsigned_long_long_variable( "t1", 0 );
    set_unsigned_long_long_variable( "t2", 1 );
    set_unsigned_long_long_variable( "t3", 0 );

    if(get_unsigned_long_long_variable("n") == 1)
        cout &lt;&lt; get_unsigned_long_long_variable("t1") &lt;&lt; endl;
    else if(get_unsigned_long_long_variable("n") == 2)
        cout &lt;&lt; get_unsigned_long_long_variable("t2") &lt;&lt; endl;
    else{
        set_unsigned_long_long_variable( "counter", 3 );
        while (get_unsigned_long_long_variable("counter") &lt;= get_unsigned_long_long_variable("n")) {
            set_unsigned_long_long_variable ( "t3", get_unsigned_long_long_variable("t1") + get_unsigned_long_long_variable("t2"));
            set_unsigned_long_long_variable ("t1" , get_unsigned_long_long_variable("t2"));
            set_unsigned_long_long_variable ("t2" , get_unsigned_long_long_variable("t3"));
            set_unsigned_long_long_variable ("counter" , get_unsigned_long_long_variable("counter") + 1);
        }
        cout &lt;&lt; get_unsigned_long_long_variable("t3") &lt;&lt; endl;
    }

    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/Fibo_HDD.cpp">Source code</a></p><br />
<p>This code is equivalent to the previous program, only difference is that it stores its variables on the disk. I will run it 50 times to see what happens:</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ Fibo_HDD.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 27.961 ms
Execution Time (Based on chrono): 44.9589 ms
Memory Usage: 0 KB

real    0.05s
user    0.00s
sys     0.03s
cpu     63%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 31.508 ms
Execution Time (Based on chrono): 31.4675 ms
Memory Usage: 0 KB

real    0.04s
user    0.00s
sys     0.03s
cpu     98%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 33.407 ms
Execution Time (Based on chrono): 173.327 ms
Memory Usage: 0 KB

real    0.18s
user    0.01s
sys     0.03s
cpu     21%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 37.039 ms
Execution Time (Based on chrono): 60.1359 ms
Memory Usage: 0 KB

real    0.07s
user    0.00s
sys     0.04s
cpu     63%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 26.895 ms
Execution Time (Based on chrono): 53.0744 ms
Memory Usage: 0 KB

real    0.06s
user    0.00s
sys     0.03s
cpu     53%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 30.281 ms
Execution Time (Based on chrono): 30.9933 ms
Memory Usage: 0 KB

real    0.03s
user    0.00s
sys     0.03s
cpu     97%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 26.92 ms
Execution Time (Based on chrono): 27.194 ms
Memory Usage: 0 KB

real    0.03s
user    0.00s
sys     0.03s
cpu     97%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 28.805 ms
Execution Time (Based on chrono): 45.9833 ms
Memory Usage: 0 KB

real    0.05s
user    0.00s
sys     0.03s
cpu     63%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 35.667 ms
Execution Time (Based on chrono): 94.1039 ms
Memory Usage: 0 KB

real    0.10s
user    0.01s
sys     0.03s
cpu     40%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 28.217 ms
Execution Time (Based on chrono): 40.1542 ms
Memory Usage: 0 KB

real    0.04s
user    0.00s
sys     0.03s
cpu     71%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 52.593 ms
Execution Time (Based on chrono): 68.8812 ms
Memory Usage: 0 KB

real    0.07s
user    0.01s
sys     0.05s
cpu     77%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 74.053 ms
Execution Time (Based on chrono): 335.553 ms
Memory Usage: 0 KB

real    0.34s
user    0.02s
sys     0.06s
cpu     23%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 29.317 ms
Execution Time (Based on chrono): 42.8699 ms
Memory Usage: 0 KB

real    0.05s
user    0.01s
sys     0.02s
cpu     70%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 50.748 ms
Execution Time (Based on chrono): 83.1821 ms
Memory Usage: 0 KB

real    0.09s
user    0.01s
sys     0.05s
cpu     62%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 50.086 ms
Execution Time (Based on chrono): 59.5969 ms
Memory Usage: 0 KB

real    0.06s
user    0.00s
sys     0.05s
cpu     84%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 26.691 ms
Execution Time (Based on chrono): 66.4044 ms
Memory Usage: 0 KB

real    0.07s
user    0.01s
sys     0.02s
cpu     43%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 27.622 ms
Execution Time (Based on chrono): 42.9472 ms
Memory Usage: 0 KB

real    0.05s
user    0.00s
sys     0.03s
cpu     66%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 26.011 ms
Execution Time (Based on chrono): 42.8584 ms
Memory Usage: 0 KB

real    0.05s
user    0.00s
sys     0.03s
cpu     63%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 46.855 ms
Execution Time (Based on chrono): 59.3697 ms
Memory Usage: 0 KB

real    0.06s
user    0.01s
sys     0.04s
cpu     79%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 43.295 ms
Execution Time (Based on chrono): 55.3742 ms
Memory Usage: 0 KB

real    0.06s
user    0.00s
sys     0.04s
cpu     79%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 56.283 ms
Execution Time (Based on chrono): 56.3353 ms
Memory Usage: 0 KB

real    0.06s
user    0.02s
sys     0.04s
cpu     98%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 55.732 ms
Execution Time (Based on chrono): 153.311 ms
Memory Usage: 0 KB

real    0.16s
user    0.02s
sys     0.04s
cpu     37%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 36.473 ms
Execution Time (Based on chrono): 90.0586 ms
Memory Usage: 0 KB

real    0.09s
user    0.01s
sys     0.03s
cpu     42%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 35.634 ms
Execution Time (Based on chrono): 60.2903 ms
Memory Usage: 0 KB

real    0.07s
user    0.01s
sys     0.03s
cpu     61%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 37.919 ms
Execution Time (Based on chrono): 41.4295 ms
Memory Usage: 0 KB

real    0.05s
user    0.00s
sys     0.04s
cpu     90%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 53.446 ms
Execution Time (Based on chrono): 55.0082 ms
Memory Usage: 0 KB

real    0.06s
user    0.02s
sys     0.04s
cpu     96%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 57.878 ms
Execution Time (Based on chrono): 215.491 ms
Memory Usage: 0 KB

real    0.22s
user    0.02s
sys     0.04s
cpu     28%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 51.583 ms
Execution Time (Based on chrono): 79.8935 ms
Memory Usage: 0 KB

real    0.08s
user    0.02s
sys     0.04s
cpu     65%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 66.857 ms
Execution Time (Based on chrono): 318.953 ms
Memory Usage: 0 KB

real    0.32s
user    0.01s
sys     0.06s
cpu     22%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 44.318 ms
Execution Time (Based on chrono): 44.4082 ms
Memory Usage: 0 KB

real    0.05s
user    0.01s
sys     0.04s
cpu     98%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 68.406 ms
Execution Time (Based on chrono): 391.37 ms
Memory Usage: 0 KB

real    0.40s
user    0.00s
sys     0.07s
cpu     18%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 64.93 ms
Execution Time (Based on chrono): 266.554 ms
Memory Usage: 0 KB

real    0.27s
user    0.01s
sys     0.06s
cpu     25%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 53.075 ms
Execution Time (Based on chrono): 95.7015 ms
Memory Usage: 0 KB

real    0.10s
user    0.01s
sys     0.05s
cpu     57%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 48.386 ms
Execution Time (Based on chrono): 51.8912 ms
Memory Usage: 0 KB

real    0.06s
user    0.00s
sys     0.05s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 64.722 ms
Execution Time (Based on chrono): 282.728 ms
Memory Usage: 0 KB

real    0.29s
user    0.00s
sys     0.06s
cpu     24%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 30.692 ms
Execution Time (Based on chrono): 51.0716 ms
Memory Usage: 0 KB

real    0.05s
user    0.01s
sys     0.03s
cpu     61%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 42.179 ms
Execution Time (Based on chrono): 71.7145 ms
Memory Usage: 0 KB

real    0.08s
user    0.00s
sys     0.04s
cpu     60%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 27.902 ms
Execution Time (Based on chrono): 49.6614 ms
Memory Usage: 0 KB

real    0.05s
user    0.01s
sys     0.02s
cpu     57%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 50.868 ms
Execution Time (Based on chrono): 65.8676 ms
Memory Usage: 0 KB

real    0.07s
user    0.00s
sys     0.06s
cpu     77%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 38.906 ms
Execution Time (Based on chrono): 229.074 ms
Memory Usage: 0 KB

real    0.23s
user    0.01s
sys     0.04s
cpu     18%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 45.282 ms
Execution Time (Based on chrono): 95.5347 ms
Memory Usage: 0 KB

real    0.10s
user    0.01s
sys     0.04s
cpu     49%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 32.539 ms
Execution Time (Based on chrono): 37.7129 ms
Memory Usage: 0 KB

real    0.04s
user    0.00s
sys     0.03s
cpu     86%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 47.754 ms
Execution Time (Based on chrono): 60.9285 ms
Memory Usage: 0 KB

real    0.07s
user    0.01s
sys     0.04s
cpu     79%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 34.381 ms
Execution Time (Based on chrono): 41.1787 ms
Memory Usage: 0 KB

real    0.05s
user    0.00s
sys     0.04s
cpu     84%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 52.619 ms
Execution Time (Based on chrono): 291.559 ms
Memory Usage: 0 KB

real    0.30s
user    0.01s
sys     0.05s
cpu     19%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 24.712 ms
Execution Time (Based on chrono): 85.2908 ms
Memory Usage: 0 KB

real    0.09s
user    0.00s
sys     0.02s
cpu     30%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 54.553 ms
Execution Time (Based on chrono): 72.2719 ms
Memory Usage: 0 KB

real    0.08s
user    0.02s
sys     0.04s
cpu     76%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 61.797 ms
Execution Time (Based on chrono): 396.595 ms
Memory Usage: 0 KB

real    0.40s
user    0.01s
sys     0.06s
cpu     16%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 24.581 ms
Execution Time (Based on chrono): 44.3478 ms
Memory Usage: 0 KB

real    0.05s
user    0.00s
sys     0.03s
cpu     58%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
12200160415121876738
Execution Time (Based on ctime): 41.316 ms
Execution Time (Based on chrono): 74.7477 ms
Memory Usage: 0 KB

real    0.08s
user    0.00s
sys     0.04s
cpu     57%</code></pre><br />
<p>The average:</p>
<pre><code class="language-md">(27.961+31.508+33.407+37.039+26.895+30.281+26.92+28.805+35.667+28.217+52.593+74.053+29.317+50.748+50.086+26.691+27.622+26.011+46.855+43.295+56.283+55.732+36.473+35.634+37.919+53.446+57.878+51.583+66.857+44.318+68.406+64.93+53.075+48.386+64.722+30.692+42.179+27.902+50.868+38.906+45.282+32.539+47.754+34.381+52.619+24.712+54.553+61.797+24.581+41.316) / 50 = 2139.694 / 50 = 42.79388
(44.9589+31.4675+173.327+60.1359+53.0744+30.9933+27.194+45.9833+94.1039+40.1542+68.8812+335.553+42.8699+83.1821+59.5969+66.4044+42.9472+42.8584+59.3697+55.3742+56.3353+153.311+90.0586+60.2903+41.4295+55.0082+215.491+79.8935+318.953+44.4082+391.37+266.554+95.7015+51.8912+282.728+51.0716+71.7145+49.6614+65.8676+229.074+95.5347+37.7129+60.9285+41.1787+291.559+85.2908+72.2719+396.595+44.3478+74.7477) / 50 = 5329.4088 / 50 = 106.588176
(0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0) / 50 = 0 / 50 = 0
(0.05s+0.04s+0.18s+0.07s+0.06s+0.03s+0.03s+0.05s+0.10s+0.04s+0.07s+0.34s+0.05s+0.09s+0.06s+0.07s+0.05s+0.05s+0.06s+0.06s+0.06s+0.16s+0.09s+0.07s+0.05s+0.06s+0.22s+0.08s+0.32s+0.05s+0.40s+0.27s+0.10s+0.06s+0.29s+0.05s+0.08s+0.05s+0.07s+0.23s+0.10s+0.04s+0.07s+0.05s+0.30s+0.09s+0.08s+0.40s+0.05s+0.08s) / 50 = 5.57 / 50 = 0.1114
(0.00s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.00s+0.01s+0.02s+0.01s+0.01s+0.00s+0.01s+0.00s+0.00s+0.01s+0.00s+0.02s+0.02s+0.01s+0.01s+0.00s+0.02s+0.02s+0.02s+0.01s+0.01s+0.00s+0.01s+0.01s+0.00s+0.00s+0.01s+0.00s+0.01s+0.00s+0.01s+0.01s+0.00s+0.01s+0.00s+0.01s+0.00s+0.02s+0.01s+0.00s+0.00s) / 50 = 0.34 / 50 = 0.0068
(0.03s+0.03s+0.03s+0.04s+0.03s+0.03s+0.03s+0.03s+0.03s+0.03s+0.05s+0.06s+0.02s+0.05s+0.05s+0.02s+0.03s+0.03s+0.04s+0.04s+0.04s+0.04s+0.03s+0.03s+0.04s+0.04s+0.04s+0.04s+0.06s+0.04s+0.07s+0.06s+0.05s+0.05s+0.06s+0.03s+0.04s+0.02s+0.06s+0.04s+0.04s+0.03s+0.04s+0.04s+0.05s+0.02s+0.04s+0.06s+0.03s+0.04s) / 50 = 1.97 / 50 = 0.0394
(63%+98%+21%+63%+53%+97%+97%+63%+40%+71%+77%+23%+70%+62%+84%+43%+66%+63%+79%+79%+98%+37%+42%+61%+90%+96%+28%+65%+22%+98%+18%+25%+57%+92%+24%+61%+60%+57%+77%+18%+49%+86%+79%+84%+19%+30%+76%+16%+58%+57%) / 50 = 2992 / 50 = 59.84


Therefore:

* Average Execution Time(Based on ctime): 42.79388 ms
* Average Execution Time(Based on chrono): 106.588176 ms
* Average Memory Usage: 0 KB
* Average Real Time: 0.1114 s
* Average User Time: 0.0068 s
* Average Sys Time: 0.0394 s
* Average CPU Usage: 59.84 %</code></pre><br />
<p>And comparing results:</p>
<pre><code class="language-md">106.588176 / 0.07143168 = 1492</code></pre><br />
<p>Wow! This time the disk appeared to be about 1500 times slower...</p><br />
<p>I'm thinking that our comparison scenario is quite simple √óŸÄ√ó We only got 94 iterations, which is very small... Let's write another code and increase the number of iterations to make it closer to real programs!</p><br />
<hr /><br />
<p>Consider the following code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;
using namespace std;

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------

    unsigned long long n = 1000, counter = n, sum_divable = 0;

    while (counter &gt; 0) {
        if( n % counter == 0 )
            ++sum_divable;
        --counter;
    }
    cout &lt;&lt; sum_divable &lt;&lt; endl;

    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/Iteration_RAM.cpp">Source code</a></p><br />
<p>This code, for each number n, iterates through all its previous numbers and prints the total number of its divisors. It is clear that for prime numbers, it prints only 2 (n and 1). It is a simple code, and it can be written more efficiently, but we don't want to do that... The purpose of this code is to perform iterational calculations so that we can measure the speed.</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ Iteration_RAM.cpp

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.288 ms
Execution Time (Based on chrono): 1.27333 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     93%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.196 ms
Execution Time (Based on chrono): 1.18127 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.101 ms
Execution Time (Based on chrono): 1.08655 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     93%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2 ms
Execution Time (Based on chrono): 1.96631 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.01s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.147 ms
Execution Time (Based on chrono): 2.11425 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.894 ms
Execution Time (Based on chrono): 1.86002 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.371 ms
Execution Time (Based on chrono): 2.33654 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.297 ms
Execution Time (Based on chrono): 2.26285 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.832 ms
Execution Time (Based on chrono): 1.79954 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     91%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.074 ms
Execution Time (Based on chrono): 2.03888 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.393 ms
Execution Time (Based on chrono): 2.36894 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     93%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.423 ms
Execution Time (Based on chrono): 2.38987 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.164 ms
Execution Time (Based on chrono): 2.13099 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.153 ms
Execution Time (Based on chrono): 2.12008 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.221 ms
Execution Time (Based on chrono): 2.18724 ms
Memory Usage: 0 KB

real    0.01s
user    0.01s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.274 ms
Execution Time (Based on chrono): 1.25876 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.239 ms
Execution Time (Based on chrono): 2.20461 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.031 ms
Execution Time (Based on chrono): 1.01659 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 2.485 ms
Execution Time (Based on chrono): 2.45185 ms
Memory Usage: 0 KB

real    0.01s
user    0.00s
sys     0.00s
cpu     92%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 1.276 ms
Execution Time (Based on chrono): 1.26014 ms
Memory Usage: 0 KB

real    0.00s
user    0.00s
sys     0.00s
cpu     92%</code></pre><br />
<p>And the average:</p>
<pre><code class="language-md">(1.288+1.196+1.101+2+2.147+1.894+2.371+2.297+1.832+2.074+2.393+2.423+2.164+2.153+2.221+1.274+2.239+1.031+2.485+1.276) / 20 = 37.859 / 20 = 1.89295
(1.27333+1.18127+1.08655+1.96631+2.11425+1.86002+2.33654+2.26285+1.79954+2.03888+2.36894+2.38987+2.13099+2.12008+2.18724+1.25876+2.20461+1.01659+2.45185+1.26014) / 20 = 37.30861 / 20 = 1.8654305
(0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0+0) / 20 = 0 / 20 = 0
(0.00s+0.00s+0.00s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.01s+0.00s+0.01s+0.00s+0.01s+0.00s) / 20 = 0.14 / 20 = 0.007
(0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.01s+0.01s+0.01s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s) / 20 = 0.05 / 20 = 0.0025
(0.00s+0.00s+0.00s+0.01s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s+0.00s) / 20 = 0.01 / 20 = 0.0005
(93%+92%+93%+92%+92%+92%+92%+92%+91%+92%+93%+92%+92%+92%+92%+92%+92%+92%+92%+92%) / 20 = 1842 / 20 = 92.1


Therefore:

* Average Execution Time(Based on ctime): 1.89295 ms
* Average Execution Time(Based on chrono): 1.8654305 ms
* Average Memory Usage: 0 KB
* Average Real Time: 0.007 s
* Average User Time: 0.0025 s
* Average Sys Time: 0.0005 s
* Average CPU Usage: 92.1 %</code></pre><br />
<p>Let's suppose we write this code just like the previous section, but in a way that only stores its main variables on the disk, let's say only 3 main variables, nothing more. No addresses, no registers, no function calls, nothing else... Just store the values of the 3 main variables on the hard disk.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/resource.h&gt;
#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

void set_unsigned_long_long_variable(string name, unsigned long long var)
{
    ofstream outfile(name + ".bin"  , ofstream::binary);
    if (outfile)
    {
        outfile.write(reinterpret_cast&lt;const char*&gt;(&amp;var), sizeof(var));
        outfile.close();
    }
    else cerr &lt;&lt; "Error opening file: " &lt;&lt; name + ".bin" &lt;&lt; endl;
}

unsigned long long get_unsigned_long_long_variable(string name)
{
    unsigned long long var = 0;
    ifstream infile(name + ".bin", ifstream::binary);
    if (infile)
    {
        infile.read(reinterpret_cast&lt;char*&gt;(&amp;var), sizeof(var));
        infile.close();
    }
    else cerr &lt;&lt; "Error opening file: " &lt;&lt; name + ".bin" &lt;&lt; endl;

    return var;
}

int main() {

    // Start execution time
    clock_t start_1 = clock();
    auto start_2 = chrono::high_resolution_clock::now();

    // Start memory usage
    struct rusage usage;
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_start = usage.ru_maxrss; // in kilobytes

    // Code ----------------------------------------------------------

    set_unsigned_long_long_variable( "n", 100000);
    set_unsigned_long_long_variable( "counter", get_unsigned_long_long_variable("n"));
    set_unsigned_long_long_variable( "sum_divable", 0);

    while (get_unsigned_long_long_variable("counter") &gt; 0) {
        if( get_unsigned_long_long_variable("n") % get_unsigned_long_long_variable("counter") == 0 )
            set_unsigned_long_long_variable( "sum_divable", get_unsigned_long_long_variable("sum_divable") + 1);
        set_unsigned_long_long_variable( "counter", get_unsigned_long_long_variable("counter") - 1);
    }
    cout &lt;&lt; get_unsigned_long_long_variable("sum_divable") &lt;&lt; endl;

    // ---------------------------------------------------------------

    // Stop measuring memory usage
    getrusage(RUSAGE_SELF, &amp;usage);
    long memory_usage_end = usage.ru_maxrss; // in kilobytes

    // Stop measuring execution time
    clock_t end_1 = clock();
    auto end_2 = chrono::high_resolution_clock::now();
    double execution_time_1 = double(end_1 - start_1) / CLOCKS_PER_SEC;
    chrono::duration&lt;double, milli&gt; execution_time_2 = end_2 - start_2;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on ctime): " &lt;&lt; execution_time_1 * 1000.0 &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time_2.count() &lt;&lt; " ms" &lt;&lt; endl;
    cout &lt;&lt; "Memory Usage: " &lt;&lt; memory_usage_end - memory_usage_start &lt;&lt; " KB" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/Iteration_HDD.cpp">Source code</a></p><br />
<p>Let's go ahead and run it to see what disaster occurs!</p>
<pre><code class="language-bash">‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ g++ Iteration_HDD.cpp 

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 8134.59 ms
Execution Time (Based on chrono): 22359.2 ms
Memory Usage: 0 KB

real    22.36s
user    1.38s
sys     6.75s
cpu     36%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 8427.09 ms
Execution Time (Based on chrono): 22312.2 ms
Memory Usage: 0 KB

real    22.31s
user    1.49s
sys     6.94s
cpu     37%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 8167.64 ms
Execution Time (Based on chrono): 22296.8 ms
Memory Usage: 0 KB

real    22.30s
user    1.45s
sys     6.72s
cpu     36%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 8040.17 ms
Execution Time (Based on chrono): 22315.6 ms
Memory Usage: 0 KB

real    22.32s
user    1.43s
sys     6.61s
cpu     36%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 8921.16 ms
Execution Time (Based on chrono): 30141.7 ms
Memory Usage: 0 KB

real    30.14s
user    1.43s
sys     7.49s
cpu     29%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 7915.38 ms
Execution Time (Based on chrono): 22112.7 ms
Memory Usage: 0 KB

real    22.12s
user    1.35s
sys     6.57s
cpu     35%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 8791.03 ms
Execution Time (Based on chrono): 26041.5 ms
Memory Usage: 0 KB

real    26.04s
user    1.41s
sys     7.38s
cpu     33%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 9897.57 ms
Execution Time (Based on chrono): 29009.1 ms
Memory Usage: 0 KB

real    29.01s
user    1.70s
sys     8.20s
cpu     34%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 8693.6 ms
Execution Time (Based on chrono): 23570.2 ms
Memory Usage: 0 KB

real    23.57s
user    1.43s
sys     7.27s
cpu     36%

‚îå‚îÄ‚îÄ(user„âødhcppc4)-[~/Desktop/Articles/4-RAM-vs-HDD-Pr/Files]
‚îî‚îÄ$ time ./a.out
36
Execution Time (Based on ctime): 9362.56 ms
Execution Time (Based on chrono): 28498.6 ms
Memory Usage: 0 KB

real    28.50s
user    1.74s
sys     7.62s
cpu     32%</code></pre><br />
<p>The average time:</p>
<pre><code class="language-md">(8134.59+8427.09+8167.64+8040.17+8921.16+7915.38+8791.03+9897.57+8693.6+9362.56) / 10 = 86350.79 / 10 = 8635.079
(22359.2+22312.2+22296.8+22315.6+30141.7+22112.7+26041.5+29009.1+23570.2+28498.6) / 10 = 248657.6 / 10 = 24865.76
(0+0+0+0+0+0+0+0+0+0) / 10 = 0 / 10 = 0
(22.36s+22.31s+22.30s+22.32s+30.14s+22.12s+26.04s+29.01s+23.57s+28.50s) / 10 = 248.67 / 10 = 24.867
(1.38s+1.49s+1.45s+1.43s+1.43s+1.35s+1.41s+1.70s+1.43s+1.74s) / 10 = 14.81 / 10 = 1.481
(6.75s+6.94s+6.72s+6.61s+7.49s+6.57s+7.38s+8.20s+7.27s+7.62s) / 10 = 71.55 / 10 = 7.155
(36%+37%+36%+36%+29%+35%+33%+34%+36%+32%) / 10 = 344 / 10 = 34.4


Therefore:

* Average Execution Time(Based on ctime): 8635.079 ms
* Average Execution Time(Based on chrono): 24865.76 ms
* Average Memory Usage: 0 KB
* Average Real Time: 24.867 s
* Average User Time: 1.481 s
* Average Sys Time: 7.155 s
* Average CPU Usage: 34.4 %</code></pre><br />
<p>And we have:</p>
<pre><code class="language-md">24865.76 / 1.8654305 = 13329</code></pre><br />
<p>Bloody hell! We're up to being 13 thousands time slower! </p><br />
<hr /><br />
<p>My guess is that in this type of computations and consecutive I/O operations for small data on the disk, the speed of calculations grows exponentially, whereas the same computations on the RAM have a linear growth.</p><br />
<p>Let's test the validity of this hypothesis. I will try different values of n in the last two programs, whic are <a href="./Files/Iteration_RAM.cpp">Iteration_RAM</a> and <a href="./Files/Iteration_HDD.cpp">Iteration_HDD</a>, and report the results. Of course, I admit that I might do something malicious and perform this final experiment on a VPS to prevent any harm to my own disk. By the way, it's also good for the credibility of the article's results because the experiment's outcomes won't be heavily overfit to my machine.</p><br />
<p><strong>Specifications of the testing machine so far:</strong></p><br />
<p>So far, The code of the article has been tested on a standard Linux machine with the following specifications:</p>
<pre><code>OS: Kali GNU/Linux Rolling x86_64
Kernel: 5.16.0-kali5-amd64
CPU: Intel i5-8250U (8) @ 3.400GHz
Memory: 11857MiB
Shell: zsh 5.8.1</code></pre><br />
<p><strong>HDD details:</strong></p>
<pre><code class="language-bash">duf</code></pre>
<pre><code class="language-bash">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ 2 local devices                                                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ MOUNTED ON ‚îÇ   SIZE ‚îÇ   USED ‚îÇ  AVAIL ‚îÇ              USE%             ‚îÇ TYPE ‚îÇ FILESYSTEM ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ /          ‚îÇ 200.2G ‚îÇ 164.0G ‚îÇ  26.0G ‚îÇ [################....]  81.9% ‚îÇ ext4 ‚îÇ /dev/sda6  ‚îÇ
‚îÇ /boot/efi  ‚îÇ 512.0M ‚îÇ  12.5M ‚îÇ 499.5M ‚îÇ [....................]   2.4% ‚îÇ vfat ‚îÇ /dev/sda5  ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ 6 special devices                                                                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ MOUNTED ON     ‚îÇ SIZE ‚îÇ   USED ‚îÇ AVAIL ‚îÇ              USE%             ‚îÇ TYPE     ‚îÇ FILESYSTEM ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ /dev           ‚îÇ 5.7G ‚îÇ     0B ‚îÇ  5.7G ‚îÇ                               ‚îÇ devtmpfs ‚îÇ udev       ‚îÇ
‚îÇ /dev/shm       ‚îÇ 5.8G ‚îÇ  23.5M ‚îÇ  5.8G ‚îÇ [....................]   0.4% ‚îÇ tmpfs    ‚îÇ tmpfs      ‚îÇ
‚îÇ /run           ‚îÇ 1.2G ‚îÇ   1.9M ‚îÇ  1.2G ‚îÇ [....................]   0.2% ‚îÇ tmpfs    ‚îÇ tmpfs      ‚îÇ
‚îÇ /run/lock      ‚îÇ 5.0M ‚îÇ     0B ‚îÇ  5.0M ‚îÇ                               ‚îÇ tmpfs    ‚îÇ tmpfs      ‚îÇ
‚îÇ /run/snapd/ns  ‚îÇ 1.2G ‚îÇ   1.9M ‚îÇ  1.2G ‚îÇ [....................]   0.2% ‚îÇ tmpfs    ‚îÇ tmpfs      ‚îÇ
‚îÇ /run/user/1000 ‚îÇ 1.2G ‚îÇ 192.0K ‚îÇ  1.2G ‚îÇ [....................]   0.0% ‚îÇ tmpfs    ‚îÇ tmpfs      ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</code></pre>
<pre><code class="language-bash">sudo hdparm -I /dev/sda6</code></pre>
<pre><code class="language-bash">/dev/sda6:

ATA device, with non-removable media
        Model Number:       HGST HTS541010B7E610                    
        Serial Number:      WXF1E673XX4S
        Firmware Revision:  03.01A03
        Transport:          Serial, SATA 1.0a, SATA II Extensions, SATA Rev 2.5, SATA Rev 2.6, SATA Rev 3.0
Standards:
        Used: unknown (minor revision code 0x006d) 
        Supported: 10 9 8 7 6 5 
        Likely used: 10
Configuration:
        Logical         max     current
        cylinders       16383   0
        heads           16      0
        sectors/track   63      0
        --
        LBA    user addressable sectors:   268435455
        LBA48  user addressable sectors:  1953525168
        Logical  Sector size:                   512 bytes
        Physical Sector size:                  4096 bytes
        Logical Sector-0 offset:                  0 bytes
        device size with M = 1024*1024:      953869 MBytes
        device size with M = 1000*1000:     1000204 MBytes (1000 GB)
        cache/buffer size  = unknown
        Form Factor: 2.5 inch
        Nominal Media Rotation Rate: 5400
Capabilities:
        LBA, IORDY(can be disabled)
        Queue depth: 32
        Standby timer values: specd by Standard, with device specific minimum
        R/W multiple sector transfer: Max = 16  Current = 16
        Advanced power management level: 254
        DMA: mdma0 mdma1 mdma2 udma0 udma1 udma2 udma3 udma4 udma5 *udma6 
             Cycle time: min=120ns recommended=120ns
        PIO: pio0 pio1 pio2 pio3 pio4 
             Cycle time: no flow control=120ns  IORDY flow control=120ns
Commands/features:
        Enabled Supported:
           *    SMART feature set
                Security Mode feature set
           *    Power Management feature set
           *    Write cache
           *    Look-ahead
           *    WRITE_BUFFER command
           *    READ_BUFFER command
           *    NOP cmd
           *    DOWNLOAD_MICROCODE
           *    Advanced Power Management feature set
                Power-Up In Standby feature set
           *    SET_FEATURES required to spinup after power up
           *    48-bit Address feature set
           *    Mandatory FLUSH_CACHE
           *    FLUSH_CACHE_EXT
           *    SMART error logging
           *    SMART self-test
           *    General Purpose Logging feature set
           *    64-bit World wide name
           *    IDLE_IMMEDIATE with UNLOAD
           *    {READ,WRITE}_DMA_EXT_GPL commands
           *    Segmented DOWNLOAD_MICROCODE
           *    Gen1 signaling speed (1.5Gb/s)
           *    Gen2 signaling speed (3.0Gb/s)
           *    Gen3 signaling speed (6.0Gb/s)
           *    Native Command Queueing (NCQ)
           *    Host-initiated interface power management
           *    Phy event counters
           *    Idle-Unload when NCQ is active
           *    NCQ priority information
           *    READ_LOG_DMA_EXT equivalent to READ_LOG_EXT
           *    DMA Setup Auto-Activate optimization
           *    Device-initiated interface power management
           *    Software settings preservation
           *    SMART Command Transport (SCT) feature set
           *    SCT Write Same (AC2)
           *    SCT Features Control (AC4)
           *    SCT Data Tables (AC5)
                unknown 206[12] (vendor specific)
                unknown 206[13] (vendor specific)
           *    Extended number of user addressable sectors 
           *    DOWNLOAD MICROCODE DMA command
           *    WRITE BUFFER DMA command
           *    READ BUFFER DMA command
           *    Data Set Management TRIM supported (limit 10 blocks)
           *    Deterministic read data after TRIM
Security: 
        Master password revision code = 65534
                supported
        not     enabled
        not     locked
        not     frozen
        not     expired: security count
                supported: enhanced erase
        180min for SECURITY ERASE UNIT. 180min for ENHANCED SECURITY ERASE UNIT.
Logical Unit WWN Device Identifier: 50014ee608088121
        NAA             : 5
        IEEE OUI        : 0014ee
        Unique ID       : 608088121
Checksum: correct</code></pre><br />
<hr /><br />
<p>Let's move on to the last part of the story, which is also the most fun part of the article in my opinion ^_^<br />
In this section, we want to do some cool scientific stuff and see how the time complexity grows, draw a plot, and make comparisons, and all those things.</p><br />
<p>Consider this code as the final code of the article:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
using namespace std;

void set_unsigned_long_long_variable(string name, unsigned long long var)
{
    ofstream outfile(name + ".bin"  , ofstream::binary);
    if (outfile)
    {
        outfile.write(reinterpret_cast&lt;const char*&gt;(&amp;var), sizeof(var));
        outfile.close();
    }
    else cerr &lt;&lt; "Error opening file: " &lt;&lt; name + ".bin" &lt;&lt; endl;
}

unsigned long long get_unsigned_long_long_variable(string name)
{
    unsigned long long var = 0;
    ifstream infile(name + ".bin", ifstream::binary);
    if (infile)
    {
        infile.read(reinterpret_cast&lt;char*&gt;(&amp;var), sizeof(var));
        infile.close();
    }
    else cerr &lt;&lt; "Error opening file: " &lt;&lt; name + ".bin" &lt;&lt; endl;

    return var;
}

int main(int argc, char** argv)  {

    // Start execution time
    auto start = chrono::high_resolution_clock::now();

    // Code ----------------------------------------------------------

    if( strcmp(argv[1], "RAM") == 0 )
    {
        unsigned long long n = stoull(argv[2]), counter = n, sum_divable = 0;
        while (counter &gt; 0) {
            if( n % counter == 0 )
                ++sum_divable;
            --counter;
        }
        cout &lt;&lt; sum_divable &lt;&lt; endl;
    }
    else if( strcmp(argv[1], "HDD") == 0 )
    {
        set_unsigned_long_long_variable( "n", stoull(argv[2]) );
        set_unsigned_long_long_variable( "counter", get_unsigned_long_long_variable("n"));
        set_unsigned_long_long_variable( "sum_divable", 0);
        while (get_unsigned_long_long_variable("counter") &gt; 0) {
            if( get_unsigned_long_long_variable("n") % get_unsigned_long_long_variable("counter") == 0 )
                set_unsigned_long_long_variable( "sum_divable", get_unsigned_long_long_variable("sum_divable") + 1);
            set_unsigned_long_long_variable( "counter", get_unsigned_long_long_variable("counter") - 1);
        }
        cout &lt;&lt; get_unsigned_long_long_variable("sum_divable") &lt;&lt; endl;
    }
    else cout &lt;&lt; "ERROR: Wronge input argument." &lt;&lt; endl;

    // ---------------------------------------------------------------

    // Stop measuring execution time
    auto end = chrono::high_resolution_clock::now();
    chrono::duration&lt;double, milli&gt; execution_time = end - start;

    // Printing result
    cout &lt;&lt; "Execution Time (Based on chrono): " &lt;&lt; execution_time.count() &lt;&lt; " ms" &lt;&lt; endl;

    return 0;
}</code></pre><br />
<p><a href="./Files/Iteration_test.cpp">Source code</a></p><br />
<p>This code is exactly the same as the previous code, but it is dynamically written. It performs the task based on the inputs received as arguments from the standard input buffer. It can perform calculations on the RAM or the hard disk, depending on the input parameters <code>n</code>.</p><br />
<p>I will test the time values spent on calculations on RAM/hard disk using this code on a Google Colab machine:</p>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 10; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(0.05557+0.04354+0.037682+0.055058+0.059299+0.040107+0.044795+0.033862+0.03316+0.030346+0.031631+0.039248+0.031442+0.030144+0.031636+0.030273+0.044436+0.035037+0.032099+0.032844+0.029726+0.031982+0.03101+0.034369+0.033597+0.042123+0.03926+0.037468+0.03927+0.042095+0.039197+0.04276+0.043037+0.058996+0.032882+0.034359+0.032656+0.034285+0.031125+0.029796+0.035702+0.030816+0.03118+0.036636+0.029955+0.029841+0.029912+0.047903+0.038854+0.033695) / 50 = 1.856696 / 50 = 0.03713392

Therefore:
* Average Execution Time(Based on chrono): 0.03713392 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 100; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(0.056729+1.59152+0.048881+0.049231+0.04922+0.043113+0.050367+0.044923+0.042751+0.043592+0.041487+0.039294+0.043805+0.047856+0.040708+0.044756+0.041053+0.040405+0.047841+0.049873+0.040557+0.039935+0.040469+0.042405+0.043633+0.042428+0.040278+0.064401+0.042753+0.049396+0.059291+0.050488+0.045674+0.047207+0.043165+0.041103+0.041197+0.037907+0.0587+0.043548+0.04071+0.04312+0.041312+0.040731+0.041073+0.047526+0.066859+0.057422+0.042882+0.043553) / 50 = 3.837128 / 50 = 0.07674256

Therefore:
* Average Execution Time(Based on chrono): 0.07674256 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 1000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(0.068803+0.059274+3.0206+0.053834+0.051958+0.051055+0.057953+0.059117+0.042785+0.048859+0.045849+0.042131+0.05188+0.042523+0.049469+0.038819+0.0395+0.041249+0.040282+0.040635+0.037002+0.044957+0.040858+0.038883+0.04276+0.061451+0.042524+0.040479+0.05396+0.041289+0.039723+0.049896+0.041293+0.039501+0.040528+0.049634+0.053361+0.041704+0.044657+0.041357+0.040148+0.045694+0.058381+0.041357+0.040849+0.036245+0.044352+0.043624+0.040995+0.036902) / 50 = 5.260939 / 50 = 0.10521878

Therefore:
* Average Execution Time(Based on chrono): 0.10521878 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 10000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(0.185036+0.154471+0.165113+0.157347+0.18171+0.132968+0.115558+0.121692+0.121769+0.113374+0.116244+0.149405+0.150177+0.125981+0.123877+0.128397+0.132772+0.172368+0.127196+0.126897+0.12715+0.115237+0.126738+0.133597+0.123583+0.124886+0.118664+0.125119+0.129162+0.115475+0.15031+0.15324+0.128633+0.158191+0.209703+0.123722+0.128189+0.135494+0.127625+0.167394+0.126804+0.124159+0.154155+0.116885+0.14578+0.119057+0.123312+0.11629+0.143316+0.114863) / 50 = 6.809085 / 50 = 0.1361817

Therefore:
* Average Execution Time(Based on chrono): 0.1361817 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 100000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(2.8513+1.01647+0.976667+0.970932+0.97964+0.995396+0.982495+0.97912+0.966483+0.970715+0.934009+0.950327+0.974002+0.975446+0.986908+0.980763+1.1284+0.982268+0.983068+0.987813+0.993953+1.02334+1.01758+1.11104+0.987194+1.04501+0.979295+0.995212+0.987408+1.01927+1.01664+0.987328+0.973787+0.975659+0.973153+0.978747+0.952589+1.09384+1.37752+1.01558+0.982577+1.0207+0.974533+1.11337+0.985381+1.01944+1.04177+1.0397+1.02442+1.04134) / 50 = 52.319598 / 50 = 1.04639196

Therefore:
* Average Execution Time(Based on chrono): 1.04639196 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 1000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(11.7602+11.6177+11.6259+9.55161+9.84909+9.6777+9.83686+9.87394+10.1924+9.75504+9.56854+9.53915+10.2645+9.75044+9.52632+9.57528+10.5565+9.7492+9.98362+13.526+11.1387+11.8642+11.5241+12.129+13.6267+11.4817+10.573+11.2104+11.0466+11.0755+10.6779+12.0456+10.9347+11.2068+11.2398+11.4614+11.3066+10.9896+11.3568+10.9231+10.6759+16.8868+14.999+16.2878+12.3337+12.8563+12.1443+10.4334+10.7875+10.6904) / 50 = 561.68729 / 50 = 11.2337458

Therefore:
* Average Execution Time(Based on chrono): 11.2337458 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 10000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(122.437+111.11+116.911+111.118+114.321+112.377+117.222+110.622+110.967+107.209+119.983+117.109+113.132+112.927+117.166+112.409+110.612+121.124+115.648+99.2176+100.546+96.6624+97.9584+95.4014+98.3823+98.5019+98.32+98.3984+95.9734+96.6039+97.2092+98.2006+96.5731+92.4531+93.6754+96.8256+97.0719+92.4971+93.3109+93.8384+92.9399+99.6457+96.2368+90.9912+90.5309+94.4321+97.6597+93.3925+94.4273+97.0904) / 50 = 5149.3715 / 50 = 102.98743

Therefore:
* Average Execution Time(Based on chrono): 102.98743 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 100000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(1153.99+1090+927.97+950.748+952.153+934.874+951.585+934.285+931.199+935.237+951.123+946.343+1044.16+1104.66+1060.29+933.39+932.839+943.719+944.238+936.994+952.082+938.932+921.093+929.203+930.171+1018.32+1079.7+1059.41+936.524+948.65+950.927+956.4+955.033+944.512+943.176+933.907+939.347+950.281+1052.11+1087.17+1069.19+952.72+921.658+921.936+932.571+954.542+931.82+944.327+943.054+937.911) / 50 = 48496.474 / 50 = 969.92948

Therefore:
* Average Execution Time(Based on chrono): 969.92948 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out RAM 1000000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(9929.45+9894.97+9401.29+9779.2+9740.14+9711.45+9411.57+9575.79+9740.8+9762.82+10157.3+9470.99+9807.61+9827.57+9903.24+9546.48+9817.56+9914.88+9835.63+9757.12+9494.87+9768.5+9804.84+9879.44+9978.79+10010.1+9716.13+9654.43+9452.93+9741.28+9716.39+9671.29+9534.45+9422.55+9740.14+9631.31+9571.77+9396.79+9789.33+10178.4+9683.12+9338.5+9541.9+9655.58+9713.08+9510.57+9530.52+9780.9+9780.28+9769.28) / 50 = 485443.32 / 50 = 9708.8664

Therefore:
* Average Execution Time(Based on chrono): 9708.8664 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 5 ]; do ./a.out RAM 10000000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(98059.1+98639.7+99670.5+99134.6+99792.6) / 5 = 495296.5 / 5 = 99059.3

Therefore:
* Average Execution Time(Based on chrono): 99059.3 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 1 ]; do ./a.out RAM 100000000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">144
Execution Time (Based on chrono): 982447 ms</code></pre>
<table>
<thead>
<tr>
<th>Iterations</th>
<th>RAM Time Complexity(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>0.03713392</td>
</tr>
<tr>
<td>100</td>
<td>0.07674256</td>
</tr>
<tr>
<td>1000</td>
<td>0.10521878</td>
</tr>
<tr>
<td>10000</td>
<td>0.1361817</td>
</tr>
<tr>
<td>100000</td>
<td>1.04639196</td>
</tr>
<tr>
<td>1000000</td>
<td>11.2337458</td>
</tr>
<tr>
<td>10000000</td>
<td>102.98743</td>
</tr>
<tr>
<td>100000000</td>
<td>969.92948</td>
</tr>
<tr>
<td>1000000000</td>
<td>9708.8664</td>
</tr>
<tr>
<td>10000000000</td>
<td>99059.3</td>
</tr>
<tr>
<td>100000000000</td>
<td>982447</td>
</tr>
</tbody>
</table><br />
<p>On this machine, it takes only 16 minutes to perform 100 billion iterations on RAM.</p><br />
<p>Now let's move on to the hard disk:</p>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out HDD 10; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(3.84055+1.47793+1.36111+1.18943+1.25027+1.06003+1.15582+1.31169+0.988887+1.08511+0.996868+1.02288+1.15027+0.970606+1.30461+1.24018+1.30114+1.01147+1.1003+1.16134+1.05386+1.00953+1.08559+1.09392+1.02795+1.04478+1.11548+1.02791+1.13904+1.43361+1.41642+1.34454+1.04273+1.10764+3.06246+1.34444+1.09299+1.02791+0.98998+1.40493+1.2629+1.37666+1.1086+1.0706+1.67073+1.05198+1.37261+1.31193+1.34244+1.18202) / 50 = 63.596671 / 50 = 1.27193342

Therefore:
* Average Execution Time(Based on chrono): 1.27193342 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out HDD 100; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(10.1258+8.54431+8.57312+9.30554+7.19626+8.57967+7.81807+6.76671+8.19687+11.3563+8.76072+8.89945+7.93218+7.15151+9.06521+8.95591+9.04594+8.77245+9.37136+7.49228+8.1699+7.5217+8.37757+8.27919+9.53812+9.14541+8.06788+7.49188+8.24989+10.9161+8.53771+8.61268+6.91477+8.33953+8.44163+6.35417+6.49716+8.86702+8.77506+9.01159+8.56295+6.69499+8.88008+8.89771+9.1845+8.44426+9.3007+9.81496+8.01047+8.43163) / 50 = 424.24087 / 50 = 8.4848174

Therefore:
* Average Execution Time(Based on chrono): 8.4848174 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 50 ]; do ./a.out HDD 1000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(83.7239+89.2962+87.393+86.0499+82.4329+92.4111+83.0183+93.2184+98.6888+88.1423+93.149+104.383+94.8324+95.2283+104.694+98.6493+92.5682+91.8928+101.478+95.2763+96.7348+96.7451+95.3717+96.2584+95.0568+104.564+94.3572+92.9837+94.5809+96.7802+95.193+94.719+94.5504+98.0115+104.346+90.0224+89.8571+84.6048+90.1275+89.0622+92.2847+91.2552+89.7745+91.942+90.7563+89.0043+94.7468+89.3705+85.9757+95.2816) / 50 = 4660.8444 / 50 = 93.216888

Therefore:
* Average Execution Time(Based on chrono): 93.216888 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 10 ]; do ./a.out HDD 10000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(878.908+868.796+868.818+868.208+921.707+945.511+940.521+901.627+872.928+876.26) / 10 = 8943.284 / 10 = 894.3284

Therefore:
* Average Execution Time(Based on chrono): 894.3284 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 5 ]; do ./a.out HDD 100000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(8944.41+9181.89+9291.08+9176.2+9019.04) / 5 = 45612.62 / 5 = 9122.524

Therefore:
* Average Execution Time(Based on chrono): 9122.524 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 5 ]; do ./a.out HDD 1000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">(93730+92787+91645.4+92535.1+94361.4) / 5 = 465058.9 / 5 = 93011.78

Therefore:
* Average Execution Time(Based on chrono): 93011.78 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 1 ]; do ./a.out HDD 10000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">64
Execution Time (Based on chrono): 904366 ms</code></pre>
<pre><code class="language-bash">counter=0; while [ $counter -lt 1 ]; do ./a.out HDD 100000000; echo ""; counter=$((counter+1)); done</code></pre>
<pre><code class="language-md">81
Execution Time (Based on chrono): 9.06014e+06 ms</code></pre><br />
<p>And we know that:</p>
<pre><code class="language-md">9.06014e+06 = 9060140</code></pre>
<table>
<thead>
<tr>
<th>Iterations</th>
<th>HDD Time Complexity(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>1.27193342</td>
</tr>
<tr>
<td>100</td>
<td>8.4848174</td>
</tr>
<tr>
<td>1000</td>
<td>93.216888</td>
</tr>
<tr>
<td>10000</td>
<td>894.3284</td>
</tr>
<tr>
<td>100000</td>
<td>9122.524</td>
</tr>
<tr>
<td>1000000</td>
<td>93011.78</td>
</tr>
<tr>
<td>10000000</td>
<td>904366</td>
</tr>
<tr>
<td>100000000</td>
<td>9060140</td>
</tr>
<tr>
<td>1000000000</td>
<td>NULL</td>
</tr>
<tr>
<td>10000000000</td>
<td>NULL</td>
</tr>
<tr>
<td>100000000000</td>
<td>NULL</td>
</tr>
</tbody>
</table><br />
<p>When we stored only three variables on the disk, what happened? Our 100 million iterations took about 3 hours, and we couldn't even reach the billionth order... This is in contrast to the approximately 9 seconds it took for 100 million iterations on RAM.</p><br />
<p>From the observed behavior of the processing time on the hard disk, we can deduce that the three values we don't know (NULLs at the table) are likely to increase tenfold each time, so the first one would probably take around 1 day, the second one would be around 12 days, and the third one should be 125 days...!</p><br />
<p>Please cosider to the table below:</p>
<table>
<thead>
<tr>
<th>Iterations</th>
<th>RAM Time Complexity(ms)</th>
<th>HDD Time Complexity(ms)</th>
<th>Ratio(HDD/RAM)</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>0.03713392</td>
<td>1.27193342</td>
<td>34.2526030</td>
</tr>
<tr>
<td>100</td>
<td>0.07674256</td>
<td>8.4848174</td>
<td>110.5620844</td>
</tr>
<tr>
<td>1000</td>
<td>0.10521878</td>
<td>93.216888</td>
<td>885.9339368</td>
</tr>
<tr>
<td>10000</td>
<td>0.1361817</td>
<td>894.3284</td>
<td>6567.1701851</td>
</tr>
<tr>
<td>100000</td>
<td>1.04639196</td>
<td>9122.524</td>
<td>8718.0753949</td>
</tr>
<tr>
<td>1000000</td>
<td>11.2337458</td>
<td>93011.78</td>
<td>8279.6764014</td>
</tr>
<tr>
<td>10000000</td>
<td>102.98743</td>
<td>904366</td>
<td>8781.3240897</td>
</tr>
<tr>
<td>100000000</td>
<td>969.92948</td>
<td>9060140</td>
<td>9341.0296179</td>
</tr>
<tr>
<td>1000000000</td>
<td>9708.8664</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>10000000000</td>
<td>99059.3</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>100000000000</td>
<td>982447</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table><br />
<p>And if we want to draw a plot of the growth, I will estimate the last three values and plot a points-and-lines chart using the Python code below:</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

iterations = [10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000]
ram_times = [0.03713392, 0.07674256, 0.10521878, 0.1361817, 1.04639196, 11.2337458, 102.98743, 969.92948, 9708.8664, 99059.3, 982447]
# hdd_times = [1.27193342, 8.4848174, 93.216888, 894.3284, 9122.524, 93011.78, 904366, 9060140, None, None, None]
last_hdd_time = 9060140 # Estimate times
hdd_times = [1.27193342, 8.4848174, 93.216888, 894.3284, 9122.524, 93011.78, 904366, 9060140, last_hdd_time*10, last_hdd_time*100, last_hdd_time*1000]


plt.plot(iterations, hdd_times, marker='o', label='HDD Time Complexity')
plt.plot(iterations, ram_times, marker='o', label='RAM Time Complexity')

plt.xlabel('Iterations')
plt.ylabel('Time Complexity (ms)')
plt.title('Points and Lines Plot')

plt.legend()

plt.show()</code></pre><br />
<p><a href="./Files/Draw_plot.py">Source code</a></p><br />
<p><img src="Files/HDD_vs_RAM_plot_small.png" alt="HDD vs RAM plot small" /></p><br />
<p><img src="Files/HDD_vs_RAM_plot.png" alt="HDD vs RAM plot" /></p><br />
<p>If we want to abstractly represent this chart, it should look like this:</p><br />
<p><img src="Files/Abstract_HDD_vs_RAM_plot.png" alt="Abstract HDD vs RAM plot" /></p><br />
<p>Lastly, I would like to mention that you can imply parallelism in this comparison and suddenly go from being a few thousand-fold slow, up to being several hundred thousand-fold slow! Of course, if you have a disk for testing... I'll stop the experiment here because I don't want to damage colab's disks. √óŸÄ√ó</p><br />
<hr /><br />
<p>One of the practical side results could be that for performing time complexity tests, if the range of execution times is very small and changes significantly each time, we need to increase the number of tests to obtain a good estimation. On the other hand, if the range of output times is very large and changes very little each time, a smaller number of tests can give us a decent estimation. ‚úÖ</p><br />
<p>Some related question and answer:</p>
<ul>
<li><em><a href="https://superuser.com/questions/1173675/how-much-faster-is-memory-ram-compared-to-ssd-for-random-access">https://superuser.com/questions/1173675/how-much-faster-is-memory-ram-compared-to-ssd-for-random-access</a></em></li>
<li><em><a href="https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk">https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk</a></em></li>
<li><em><a href="https://queue.acm.org/detail.cfm?id=1563874">https://queue.acm.org/detail.cfm?id=1563874</a></em></li>
</ul><br />
<p>And that's it, the hard disk is on average 100,000 times slower than RAM:))</p><br />
<h2>Future Work</h2><br />
<p>In your own article, you can work on scenarios that can show even greater speed differences. You can perform parallelism in the second phase of the experiment, use different disks, or even use different clusters on different RAID systems. Additionally, if feasible, you can actually let the disk perform calculations for 125 days to obtain a real comparison result:)</p><br />
<h2>Copyright</h2><br />
<p>This is a free and open-source article under the license of GFDL1-3, so permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License.</p><br />
<h2>Author</h2>
<ul>
<li>Behrad B. (behroora@yahoo.com)</li>
</ul><br />
<h2>References</h2>
<ul>
<li><a href="https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm">https://faculty.etsu.edu/tarnoff/ntes2150/memory/memory.htm</a></li>
<li><a href="https://electronics.stackexchange.com/questions/562038/how-is-a-memory-location-accessed-by-random-access/562041#562041">https://electronics.stackexchange.com/questions/562038/how-is-a-memory-location-accessed-by-random-access/562041#562041</a></li>
<li>Database System Concepts, 6th Edition</li>
<li><a href="http://www.foundersatwork.com/steve-wozniak.html">http://www.foundersatwork.com/steve-wozniak.html</a></li>
<li><a href="https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90">https://jadi.net/2014/02/radiogeek-36-wozniak-and-narenji-90</a></li>
<li><a href="https://blog.codinghorror.com/understanding-user-and-kernel-mode">https://blog.codinghorror.com/understanding-user-and-kernel-mode</a></li>
<li><a href="https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys">https://askubuntu.com/questions/920920/how-to-interpret-time-real-user-and-sys</a></li>
<li><a href="https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems">https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems</a></li>
<li><a href="https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine">https://unix.stackexchange.com/questions/53302/why-would-the-real-time-be-much-higher-than-the-user-and-sys-times-combine</a></li>
<li><a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1</a></li>
</ul><br />
<h2>Issues related to this Article</h2><br />
<p>This free and open-source article is available at <a href="https://github.com/TadavomnisT/Free_Books-Documents">Free Books/Documents</a> repository with the following link:</p><br />
<p><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En">https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En</a></p>
<ul>
<li><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En">Comparison of RAM and HDD Read/Write Speeds üî•</a><ul>
<li><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En#what-is-a-ram">What is a RAM?</a></li>
<li><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En#what-is-a-hard-disk">What is a Hard-Disk?</a></li>
<li><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En#comparison-of-hard-disk-and-ram-speed">Speed Comparison between RAM and HDD</a><ul>
<li><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En#phase-1-comparing-the-speed-of-ram-and-hard-disk-in-handling-large-data">Phase 1: Comparing the Speed of RAM and Hard Disk in Handling Large Data</a></li>
<li><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-En#phase-two-comparing-the-speed-of-ram-and-hard-disk-for-small-data-and-fast-sequential-allocations">Phase Two: Comparing the Speed of RAM and Hard Disk for Small Data and Fast Sequential Allocations</a></li>
</ul>
</li>
</ul>
</li>
</ul><br />
<p>The Persian version of this article:</p><br />
<p><a href="https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-Pr">https://github.com/TadavomnisT/Free_Books-Documents/tree/main/Articles/4-RAM-vs-HDD-Pr</a></p><br />
<p><strong>Any scientific mistakes, issues, questions, or discussions related to this article can be posted through Issues section of repository or sent by email:</strong></p>
<ul>
<li><a href="https://github.com/TadavomnisT/Free_Books-Documents/issues">https://github.com/TadavomnisT/Free_Books-Documents/issues</a></li>
<li>behroora@yahoo.com</li>
</ul></div><script src="https://tadavomnist.github.io/assets/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://tadavomnist.github.io/assets/js/MathJax.js" type="text/javascript"></script><script type="text/javascript">MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});</script><script>document.addEventListener("DOMContentLoaded", ev => document.body.querySelectorAll("#container > *").forEach(elm => elm.setAttribute("dir", "auto")));</script></body></html>